<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>mysql实战45讲笔记 - xingliuhua博客</title><meta name="Description" content="mysql实战45讲笔记"><meta property="og:title" content="mysql实战45讲笔记" />
<meta property="og:description" content="mysql实战45讲笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/mysql_45%E8%AE%B2%E7%AC%94%E8%AE%B0/" /><meta property="og:image" content="https://xingliuhua.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-20T17:55:28+08:00" />
<meta property="article:modified_time" content="2021-01-20T17:55:28+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="mysql实战45讲笔记"/>
<meta name="twitter:description" content="mysql实战45讲笔记"/>
<meta name="application-name" content="xingliuhua博客">
<meta name="apple-mobile-web-app-title" content="xingliuhua博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/mysql_45%E8%AE%B2%E7%AC%94%E8%AE%B0/" /><link rel="prev" href="https://xingliuhua.github.io/posts/docker_%E7%B3%BB%E7%BB%9F%E5%AD%A6docker%E7%AC%94%E8%AE%B0/" /><link rel="next" href="https://xingliuhua.github.io/posts/mysql_%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "mysql实战45讲笔记",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/mysql_45%E8%AE%B2%E7%AC%94%E8%AE%B0\/"
        },"genre": "posts","keywords": "mysql","wordcount":  19918 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/mysql_45%E8%AE%B2%E7%AC%94%E8%AE%B0\/","datePublished": "2021-01-20T17:55:28+08:00","dateModified": "2021-01-20T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "mysql实战45讲笔记"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">mysql实战45讲笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-20">2021-01-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 19918 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 40 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li><a href="#查询语句执行流程">查询语句执行流程</a>
      <ol>
        <li><a href="#连接器">连接器</a></li>
        <li><a href="#查询缓存">查询缓存</a></li>
        <li><a href="#分析器">分析器</a></li>
        <li><a href="#优化器">优化器</a></li>
        <li><a href="#执行器">执行器</a></li>
      </ol>
    </li>
    <li><a href="#更新语句执行流程">更新语句执行流程</a></li>
    <li><a href="#刷脏页">刷脏页</a></li>
    <li><a href="#事务隔离">事务隔离</a>
      <ol>
        <li><a href="#undolog">undolog</a></li>
      </ol>
    </li>
    <li><a href="#索引">索引</a></li>
    <li><a href="#锁">锁</a>
      <ol>
        <li><a href="#全局锁">全局锁</a></li>
        <li><a href="#表级锁">表级锁</a></li>
        <li><a href="#行锁">行锁</a></li>
      </ol>
    </li>
    <li><a href="#mvcc视图">mvcc视图</a></li>
    <li><a href="#当前读">当前读</a></li>
    <li><a href="#更新过程和change-buffer">更新过程和change buffer</a></li>
    <li><a href="#普通和唯一索引选择">普通和唯一索引选择</a>
      <ol>
        <li><a href="#插入记录的区别">插入记录的区别</a></li>
        <li><a href="#普通索引和唯一索引选择总结">普通索引和唯一索引选择总结</a></li>
      </ol>
    </li>
    <li><a href="#索引的选择">索引的选择</a>
      <ol>
        <li><a href="#扫描行数的预判">扫描行数的预判</a></li>
      </ol>
    </li>
    <li><a href="#字符串索引">字符串索引</a></li>
    <li><a href="#刷脏页-1">刷脏页</a></li>
    <li><a href="#表空间回收">表空间回收</a>
      <ol>
        <li><a href="#innodb_file_per_table配置">innodb_file_per_table配置</a></li>
        <li><a href="#数据删除流程">数据删除流程</a></li>
        <li><a href="#重建表">重建表</a></li>
      </ol>
    </li>
    <li><a href="#count">count(*)</a>
      <ol>
        <li><a href="#count函数">count函数</a></li>
      </ol>
    </li>
    <li><a href="#更新行数问题">更新行数问题</a></li>
    <li><a href="#索引失效">索引失效</a>
      <ol>
        <li><a href="#条件字段函数操作">条件字段函数操作</a></li>
        <li><a href="#隐式类型转换">隐式类型转换</a></li>
        <li><a href="#隐式字符编码转换">隐式字符编码转换</a></li>
      </ol>
    </li>
    <li><a href="#解决幻读">解决幻读</a>
      <ol>
        <li><a href="#间隙锁">间隙锁</a></li>
        <li><a href="#next-key锁">next-key锁</a></li>
        <li><a href="#next-key加锁规则">next-key加锁规则</a></li>
      </ol>
    </li>
    <li><a href="#binlog-redolog写入和落盘">binlog redolog写入和落盘</a>
      <ol>
        <li><a href="#binglog写入机制">binglog写入机制</a></li>
        <li><a href="#redolog写入机制">redolog写入机制</a></li>
      </ol>
    </li>
    <li><a href="#主从同步">主从同步</a>
      <ol>
        <li><a href="#同步过程">同步过程</a></li>
        <li><a href="#binlog-的三种格式对比">binlog 的三种格式对比</a></li>
      </ol>
    </li>
    <li><a href="#服务端返回数据">服务端返回数据</a></li>
    <li><a href="#join">join</a>
      <ol>
        <li><a href="#index-nested-loop-join">Index Nested-Loop Join</a></li>
        <li><a href="#simple-nested-loop-join">Simple Nested-Loop Join</a></li>
        <li><a href="#block-nested-loop-join">Block Nested-Loop Join</a></li>
        <li><a href="#multi-range-read-优化">Multi-Range Read 优化</a></li>
      </ol>
    </li>
    <li><a href="#自增主键">自增主键</a>
      <ol>
        <li><a href="#自增值修改机制">自增值修改机制</a></li>
        <li><a href="#自增值的修改时机">自增值的修改时机</a></li>
      </ol>
    </li>
    <li><a href="#row_idxidtx_id">row_id,Xid,tx_id</a>
      <ol>
        <li><a href="#innodb-系统自增-row_id">InnoDB 系统自增 row_id</a></li>
        <li><a href="#xid">Xid</a></li>
        <li><a href="#innodb-trx_id">Innodb trx_id</a></li>
        <li><a href="#thread_id">thread_id</a></li>
      </ol>
    </li>
    <li><a href="#案例">案例</a>
      <ol>
        <li><a href="#先插入再更新阻塞">先插入、再更新阻塞</a></li>
        <li><a href="#先插入后提交再更新-重复读结果不一样">先插入后提交、再更新 重复读结果不一样</a></li>
      </ol>
    </li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h1 id="查询语句执行流程">查询语句执行流程</h1>
<p>MySQL 的基本架构示意图：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84%e5%9b%be.png"
        data-srcset="./pic_mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84%e5%9b%be.png, ./pic_mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84%e5%9b%be.png 1.5x, ./pic_mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84%e5%9b%be.png 2x"
        data-sizes="auto"
        alt="./pic_mysql逻辑架构图.png"
        title="./pic_mysql逻辑架构图.png" /></p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<h2 id="连接器">连接器</h2>
<p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。
mysql -h ip -P port -u user -p
连接命令中的 mysql 是客户端工具。</p>
<p>连接器会到权限表里面查出你拥有的权限。之后，<code>这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</code>
这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p>
<h2 id="查询缓存">查询缓存</h2>
<p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>
<p><code>返回缓存内容到客户端时会校验是否对该表有权限。</code></p>
<p>每当表有更新时都会把该表的缓存给清空，所以缓存适合不经常变的表。我们可以指定查询时使用缓存：
select SQL_CACHE * from T where ID=10；</p>
<p>MySQL 8.0 版本直接将查询缓存的整块功能删掉了。</p>
<h2 id="分析器">分析器</h2>
<p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p>
<p>分析器先会做“词法分析”，然后做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>
<p>查询的字段并不在表中，也会在分析阶段中报错。</p>
<h2 id="优化器">优化器</h2>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<h2 id="执行器">执行器</h2>
<p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p><code>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限。</code></p>
<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<h1 id="更新语句执行流程">更新语句执行流程</h1>
<ol>
<li>你执行语句前要先连接数据库，这是连接器的工作。</li>
<li>分析器会通过词法和语法解析知道这是一条更新语句。</li>
<li>优化器决定要使用 ID 这个索引。</li>
<li>执行器负责具体执行，找到这一行，然后更新。</li>
</ol>
<p>更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。
这两种日志有以下三点不同。</p>
<p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
<p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
<p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
<p>我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p>
<ol>
<li>
<p>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li>
<p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li>
<p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li>
<p>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p>
</li>
<li>
<p>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>
</li>
</ol>
<blockquote>
<p>redolog也并不是每次都直接写到磁盘中，虽然是顺序写，也没有必要每次都立即刷到磁盘中，而是先写到Log Buffer中，再批量刷到磁盘中。什么时候刷取决于innodb_flush_log_at_trx_commit配置。</p>
</blockquote>
<h1 id="刷脏页">刷脏页</h1>
<p>MySQL实际更新的不是磁盘，而是内存。当内存数据页 和 磁盘数据页内容不一致的时候，这个内存页 就为 “脏页”；内存数据页写入磁盘后，内存数据页 和 磁盘数据页内容一致，称之为 “干净页”。</p>
<p>那么，什么情况会引发数据库的 flush 过程呢？</p>
<p>第一种场景是InnoDB 的 redo log 写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。</p>
<p>第二种场景对应的就是系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</p>
<p>第三种场景对应的就是 MySQL 认为系统“空闲”的时候。当然，MySQL忙起来可是会很快就能把redo log 记满的，所以要合理地安排时间，即使是忙的时候，也要见缝插针地找时间，只要有机会就刷一点“脏页”。</p>
<p>第四种场景对应的就是 MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快</p>
<h1 id="事务隔离">事务隔离</h1>
<p>数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p>
<p>在“可重复读”隔离级别下，这个视图是在事务开始的时候创建的（begin语句时并不会，第一条查询语句才会创建read view，一致性视图是在第执行第一个快照读语句时创建的，如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。），整个事务存在期间都用这个视图。</p>
<p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p>
<p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念，是用的读锁。</p>
<p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<h2 id="undolog">undolog</h2>
<p>每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p>回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</p>
<p>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p>
<p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<h1 id="索引">索引</h1>
<ul>
<li>
<p>索引维护中可能会造成页的分裂，有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。</p>
</li>
<li>
<p>树高其实取决于叶子树（数据行数）和“N叉树”的N。 而N是由页大小和索引大小决定的。
N 叉树中非叶子节点存放的是索引信息，索引包含 Key 和 Point 指针。Point 指针固定为 6 个字节，假如 Key 为 10 个字节，那么单个索引就是 16 个字节。如果 B + 树中页大小为 16 K，那么一个页就可以存储 1024 个索引，此时 N 就等于 1024。</p>
</li>
<li>
<p>InnoDB会把主键字段放到索引定义字段后面， 当然同时也会去重。
所以，当联合主键是(a,b)的时候，
定义为c的索引，实际上是（c,a,b);
定义为(c,a)的索引，实际上是(c,a,b)
定义为(c,b）的索引，实际上是（c,b,a)</p>
</li>
</ul>
<h1 id="锁">锁</h1>
<h2 id="全局锁">全局锁</h2>
<p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要<code>让整个库处于只读状态</code>的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>全局锁的典型使用场景是，做全库逻辑备份。</p>
<h2 id="表级锁">表级锁</h2>
<p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<p><strong>表锁</strong>的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<p>另一类表级的锁是 <strong>MDL（metadata lock)</strong>。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此，在 MySQL 5.5 版本中引入了 MDL，<code>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</code></p>
<p>来个案例：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysqlmdl%e9%94%81.jpeg"
        data-srcset="./pic_mysqlmdl%e9%94%81.jpeg, ./pic_mysqlmdl%e9%94%81.jpeg 1.5x, ./pic_mysqlmdl%e9%94%81.jpeg 2x"
        data-sizes="auto"
        alt="./pic_mysqlmdl锁.jpeg"
        title="./pic_mysqlmdl锁.jpeg" /></p>
<p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p>
<p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p>
<p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p><strong>如何安全地给小表加字段？</strong></p>
<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p>
<h2 id="行锁">行锁</h2>
<p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。</p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong>。</p>
<h1 id="mvcc视图">mvcc视图</h1>
<p>InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。
它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，<code>这个快照是基于整库的</code>。</p>
<p>如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。</p>
<p>实际上，我们并不需要拷贝出这 100G 的数据。</p>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的，每个数据版本有自己的 row trx_id。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p>如图 所示，就是一个记录被多个事务连续更新后的状态。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql_mvcc%e8%a7%86%e5%9b%be%e9%93%be.png"
        data-srcset="./pic_mysql_mvcc%e8%a7%86%e5%9b%be%e9%93%be.png, ./pic_mysql_mvcc%e8%a7%86%e5%9b%be%e9%93%be.png 1.5x, ./pic_mysql_mvcc%e8%a7%86%e5%9b%be%e9%93%be.png 2x"
        data-sizes="auto"
        alt="./pic_mysql_mvcc视图链.png"
        title="./pic_mysql_mvcc视图链.png" /></p>
<p>图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的</p>
<h1 id="当前读">当前读</h1>
<p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</p>
<p>其实，除了 update 语句外，select 语句如果加锁，也是当前读。</p>
<p>换句话说当前读就是读的数据最新的内容，不管什么快照可见不可见。</p>
<p>而读已提交和可重复读级别下普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p>
<h1 id="更新过程和change-buffer">更新过程和change buffer</h1>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，然后写redolog，内存中数据也磁盘中数据不一致，不要紧，刷脏页即可。</p>
<p><strong>而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了</strong>。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为** merge**。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>
<p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。</p>
<p>在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)。
它是一种应用在非唯一普通索引页(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的<code>目的是降低写操作的磁盘IO，提升数据库性能。</code></p>
<p><strong>change buffer适用场景？</strong>
因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>
<p><strong>总结更新过程</strong>
案例：
我们假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。</p>
<p>这条更新语句做了如下的操作：</p>
<p>Page 1 在内存中，直接更新内存；</p>
<p>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</p>
<p>将上述两个动作记入 redo log 中</p>
<h1 id="普通和唯一索引选择">普通和唯一索引选择</h1>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>
<p><code>因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</code></p>
<h2 id="插入记录的区别">插入记录的区别</h2>
<p>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</p>
<p>第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下：</p>
<p>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。
这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p>
<p>但，这不是我们关注的重点。</p>
<p>第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：</p>
<p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；
对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。
将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<h2 id="普通索引和唯一索引选择总结">普通索引和唯一索引选择总结</h2>
<p>其实，这两类索引在查询能力上是没差别的，InnoDB 的数据是按数据页为单位来读写的。
也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。
当找到 k=5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。</p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>
<h1 id="索引的选择">索引的选择</h1>
<p>选择索引是优化器的工作。
而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，<code>扫描行数</code>是影响执行代价的因素之一。</p>
<p>不过扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
<h2 id="扫描行数的预判">扫描行数的预判</h2>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p>
<p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p>可以使用 show index 方法，看到一个索引的基数。</p>
<p><strong>MySQL 是怎样得到索引的基数的呢？</strong>
采样统计！
采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。
analyze table t 命令，可以用来重新统计索引信息。</p>
<p>索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。
explain语句可以看到预计扫描行数。</p>
<h1 id="字符串索引">字符串索引</h1>
<p>字符串列当索引时，可以指定索引的长度，叫做前缀索引</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">idx_email</span><span class="p">(</span><span class="n">email</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span><span class="w">
</span></span></span></code></pre></div><p>合适的前缀索引可以节省空间。
查找前缀索引后，必须回表再次判断是否完全相等，所以<code>覆盖索引的好处就没有了</code>。这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p>
<h1 id="刷脏页-1">刷脏页</h1>
<p>InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志），也就是《孔乙己》里咸亨酒店掌柜用来记账的粉板，在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</p>
<p>做下类比的话，掌柜记账的账本是数据文件，记账用的粉板是日志文件（redo log），掌柜的记忆就是内存。</p>
<p>掌柜总要找时间把账本更新一下，这对应的就是把内存里的数据写入磁盘的过程，术语就是 flush。在这个 flush 操作执行之前，孔乙己的赊账总额，其实跟掌柜手中账本里面的记录是不一致的。因为孔乙己今天的赊账金额还只在粉板上，而账本里的记录是老的，还没把今天的赊账算进去。</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“<strong>脏页</strong>”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
<p>不论是脏页还是干净页，都在内存中。在这个例子里，内存对应的就是掌柜的记忆。</p>
<p><strong>什么情况会引发数据库的 flush 过程?</strong></p>
<ol>
<li>第一种场景是，粉板满了，记不下了。这时候如果再有人来赊账，掌柜就只得放下手里的活儿，将粉板上的记录擦掉一些，留出空位以便继续记账。当然在擦掉之前，他必须先将正确的账目记录到账本中才行。
这个场景，对应的就是 InnoDB 的 redo log 写满了。</li>
<li>第二种场景是，这一天生意太好，要记住的事情太多，掌柜发现自己快记不住了，赶紧找出账本把孔乙己这笔账先加进去。
这种场景，对应的就是系统内存不足。</li>
<li>第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，不如更新账本。
这种场景，对应的就是 MySQL 认为系统“空闲”的时候。</li>
<li>第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。
这种场景，对应的就是 MySQL 正常关闭的情况。</li>
</ol>
<h1 id="表空间回收">表空间回收</h1>
<h2 id="innodb_file_per_table配置">innodb_file_per_table配置</h2>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p>
<p>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</p>
<p>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</p>
<p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。</p>
<p>我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p>
<h2 id="数据删除流程">数据删除流程</h2>
<p>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p>
<p>当某条记录标记为已删除的时候可以被<code>符合条件的数据再次插入复用</code>。比如ID为10的记录标记为删除，再插入ID为10的数据时就能复用，如果插入ID为12的数据，是不能被复用的。</p>
<p>大量增删改的操作，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。</p>
<h2 id="重建表">重建表</h2>
<p>你可以使用 **alter table A engine=InnoDB **命令来重建表。
在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。而在MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。</p>
<p><strong>alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</strong></p>
<p>为什么要退化呢？为了实现 Online，MDL 读锁不会阻塞增删改操作。</p>
<p>那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做 DDL。</p>
<p>而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p>
<h1 id="count">count(*)</h1>
<p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p>
<ul>
<li>
<p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</p>
</li>
<li>
<p>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</p>
</li>
</ul>
<p>这里需要注意的是，我们在这篇文章里讨论的是没有过滤条件的 count(*)，如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。</p>
<p><strong>那为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？</strong></p>
<p>这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p>
<p>show table status 命令里面有TABLE_ROWS，是通过采样估算的，不准确。</p>
<h2 id="count函数">count函数</h2>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>
<p>count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>
<ul>
<li>
<p>对于 <strong>count(主键 id)</strong> 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
</li>
<li>
<p>对于** count(1)** 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
</li>
</ul>
<p>单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p>
<ul>
<li>对于 **count(字段) **来说：
如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
<li>对于<strong>count(*)</strong> 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</li>
</ul>
<p><code>按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)，所以我建议你，尽量使用 count(*)。</code></p>
<h1 id="更新行数问题">更新行数问题</h1>
<p>当 MySQL 去更新一行，但是要修改的值跟原来的值是相同的，这时候 MySQL 会真的去执行一次修改吗？还是看到值相同就直接返回呢？</p>
<p>假设，当前表 t 里的值是 (1,2)。执行update t set a=2 where id =1;会出现什么情况。</p>
<p>案例1：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0.png"
        data-srcset="./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0.png, ./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0.png 1.5x, ./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0.png 2x"
        data-sizes="auto"
        alt="./pic_mysql_相同更新.png"
        title="./pic_mysql_相同更新.png" />
session B 的 update 语句被 blocked 了，加锁这个动作是 InnoDB 才能做的。</p>
<p>InnoDB 认真执行了“把这个值修改成 (1,2)&ldquo;这个操作，该加锁的加锁，该更新的更新。</p>
<p>案例2：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b2.png"
        data-srcset="./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b2.png, ./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b2.png 1.5x, ./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b2.png 2x"
        data-sizes="auto"
        alt="./pic_mysql_相同更新_示例2.png"
        title="./pic_mysql_相同更新_示例2.png" />
session A 的第二个 select 语句是一致性读（快照读)，它是不能看见 session B 的更新的。</p>
<p>案例3：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b3.png"
        data-srcset="./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b3.png, ./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b3.png 1.5x, ./pic_mysql_%e7%9b%b8%e5%90%8c%e6%9b%b4%e6%96%b0_%e7%a4%ba%e4%be%8b3.png 2x"
        data-sizes="auto"
        alt="./pic_mysql_相同更新_示例3.png"
        title="./pic_mysql_相同更新_示例3.png" />
现在它返回的是 (1,3)，表示它看见了某个新的版本，这个版本只能是 session A 自己的 update 语句做更新的时候生成。</p>
<p><code>在这个语句里面，MySQL 认为读出来的值，只有一个确定的 (id=1), 而要写的是 (a=3)，只从这两个信息是看不出来“不需要修改”的。而update t set a =3 where id =1 and a=3；就不同了，更新的目的和条件是一样的，明显浪费</code></p>
<h1 id="索引失效">索引失效</h1>
<h2 id="条件字段函数操作">条件字段函数操作</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tradelog</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">month</span><span class="p">(</span><span class="n">t_modified</span><span class="p">)</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="err">不能使用索引</span><span class="w">
</span></span></span></code></pre></div><p>为什么条件是 where t_modified=&lsquo;2018-7-1’的时候可以用上索引，而改成 where month(t_modified)=7 的时候就不行了？</p>
<p>B+ 树提供的这个快速定位能力，来源于同一层兄弟节点的有序性。</p>
<p>但是，如果计算 month() 函数的话，你会看到传入 7 的时候，在树的第一层就不知道该怎么办了。只能一个一个来遍历t_modified索引。</p>
<h2 id="隐式类型转换">隐式类型转换</h2>
<p>字符串和数字进行对比的时候，要进行转换，<code>规则是字符串转为数字</code>。
示例：
user表age int;  phone varchar均分别有索引。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">age</span><span class="o">=</span><span class="s1">&#39;5&#39;</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="err">会使用到索引</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">phone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123456</span><span class="p">;</span><span class="o">//</span><span class="err">索引失效</span><span class="w">
</span></span></span></code></pre></div><h2 id="隐式字符编码转换">隐式字符编码转换</h2>
<p>字符集不同<strong>可能</strong>用不上索引。</p>
<p>字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p>
<p>字符集不同只是条件之一，连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因。</p>
<h1 id="解决幻读">解决幻读</h1>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<h2 id="间隙锁">间隙锁</h2>
<p>间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">t</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">d</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql_%e9%97%b4%e9%9a%99%e9%94%81.png"
        data-srcset="./pic_mysql_%e9%97%b4%e9%9a%99%e9%94%81.png, ./pic_mysql_%e9%97%b4%e9%9a%99%e9%94%81.png 1.5x, ./pic_mysql_%e9%97%b4%e9%9a%99%e9%94%81.png 2x"
        data-sizes="auto"
        alt="./pic_mysql_间隙锁.png"
        title="./pic_mysql_间隙锁.png" /></p>
<p>这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p>
<p>跟行锁有冲突关系的是“另外一个行锁”。但是间隙锁不一样，<code>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</code>。间隙锁之间都不存在冲突关系。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="o">=</span><span class="mi">7</span><span class="w"> </span><span class="k">lock</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">share</span><span class="w"> </span><span class="k">mode</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="o">=</span><span class="mi">7</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>因为表 t 里并没有 c=7 这个记录，因此 session A 加的是间隙锁 (5,10)。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
<h2 id="next-key锁">next-key锁</h2>
<p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是<strong>前开后闭区间</strong>。加锁过程是要分成间隙锁和行锁两段来执行的。</p>
<p>举个例子，“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁。</p>
<p>也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>
<h2 id="next-key加锁规则">next-key加锁规则</h2>
<p>两个“原则”、两个“优化”和一个“bug”。</p>
<ul>
<li>
<p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</p>
</li>
<li>
<p>原则 2：查找过程中访问到的对象才会加锁。</p>
</li>
<li>
<p>优化 1：索引上的等值查询，给<code>唯一索引</code>加锁的时候，next-key lock 退化为行锁。</p>
</li>
<li>
<p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
</li>
<li>
<p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
</li>
</ul>
<p>通过一些案例理解，先看表</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">t</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">d</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p><strong>案例1：等值查询间隙锁</strong>
update t set d = d+1 where id =7;
表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<p>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</p>
<p>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</p>
<p>所以，此时锁是加在主键上的(5,10)，session B 要往这个间隙里面插入 id=8 的记录会被锁住。</p>
<p><strong>案例2：非唯一索引等值锁</strong>
这是关于覆盖索引上的锁：</p>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sessionC</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;<!-- raw HTML omitted -->select id from t where c =5 lock in share mode;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d =d d+1 where id =5;<!-- raw HTML omitted -->(query ok)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into t values(7,7,7);<!-- raw HTML omitted -->(block)</td>
</tr>
</tbody>
</table>
<p>session A 要给索引 c 上 c=5 的这一行加上读锁。</p>
<p>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</p>
<p>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</p>
<p>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</p>
<p>根据原则 2 ，<code>只有访问到的对象才会加锁</code>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</p>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>
<p><code>在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</code></p>
<p><strong>案例3：主键索引范围锁</strong>
select * from t where id&gt;=10 and id&lt;11 for update;</p>
<p>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</p>
<p>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</p>
<p>所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果你就能理解了。</p>
<p>这里你需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p>
<p><strong>案例4：非唯一索引范围锁</strong>
select * from t where c &gt;= 10 and c &lt;11 for update;</p>
<p>在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>
<p><strong>案例5：唯一索引范围锁 bug</strong>
select * from t where id &gt;10 and id &lt;=15 for update;</p>
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<p>所以你看到了，session B 要更新 id=20 这一行，是会被锁住的。</p>
<p><strong>案例7：limit 语句加锁</strong></p>
<p>delete from t where c =10 limit 2;</p>
<p>ession A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。</p>
<p>delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>
<p><strong>案例八：一个死锁的例子</strong></p>
<table>
<thead>
<tr>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;<!-- raw HTML omitted -->select id from t where c =10 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d = d+1 where c =10;<!-- raw HTML omitted -->(blocked)</td>
</tr>
<tr>
<td>insert into t values(8,8,8);</td>
<td></td>
</tr>
</tbody>
</table>
<p>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</p>
<p>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</p>
<p>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</p>
<p>其实，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>
<p>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p>
<p><strong>案例9：带排序的</strong></p>
<table>
<thead>
<tr>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;<!-- raw HTML omitted -->select * from t where c &gt;=15 and c&lt;=20 order by c desc lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into t values(6,6,6);<!-- raw HTML omitted -->(blocked)</td>
</tr>
</tbody>
</table>
<p>由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。</p>
<p>在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session B 的 insert 语句的原因。</p>
<p>在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 select *，所以会在主键 id 上加三个行锁。</p>
<p>因此，session A 的 select 语句锁的范围就是：
索引 c 上 (5, 25)；
主键索引上 id=15、20 两个行锁。</p>
<blockquote>
<p>最终的加锁是根据实际执行情况来的。所以，如果一个 select * from … for update 语句，优化器决定使用全表扫描，那么就会把主键索引上 next-key lock 全加上。</p>
</blockquote>
<h1 id="binlog-redolog写入和落盘">binlog redolog写入和落盘</h1>
<h2 id="binglog写入机制">binglog写入机制</h2>
<p>binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p><code>一个事务的 binlog 是不能被拆开的</code>，因此不论这个事务多大，也要确保一次性写入。</p>
<p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。</p>
<p><strong>write</strong>，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</p>
<p><strong>fsync</strong>，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ul>
<li>
<p>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</p>
</li>
<li>
<p>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</p>
</li>
<li>
<p>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p>
</li>
</ul>
<p>在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。
对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p>
<h2 id="redolog写入机制">redolog写入机制</h2>
<p>事务在执行过程中，生成的 redo log 是要先写到 redo log buffer 的。</p>
<p>如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p>
<p>redo log 可能存在的三种状态：</p>
<ol>
<li>
<p>存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</p>
</li>
<li>
<p>写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</p>
</li>
<li>
<p>持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</p>
</li>
</ol>
<p>日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。</p>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p>
<ul>
<li>
<p>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</p>
</li>
<li>
<p>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</p>
</li>
<li>
<p>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</p>
</li>
</ul>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<p>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</p>
<p>除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。</p>
<p>一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</p>
<p>另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</p>
<p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
<p>WAL 机制主要得益于两个方面：</p>
<ol>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</li>
</ol>
<h1 id="主从同步">主从同步</h1>
<h2 id="同步过程">同步过程</h2>
<p>节点 A 到 B 这条线的内部流程是什么样的：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic_mysql%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.png"
        data-srcset="./pic_mysql%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.png, ./pic_mysql%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.png 1.5x, ./pic_mysql%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5.png 2x"
        data-sizes="auto"
        alt="./pic_mysql主从同步.png"
        title="./pic_mysql主从同步.png" /></p>
<p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>
<p>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</p>
</li>
<li>
<p>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</p>
</li>
<li>
<p>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</p>
</li>
<li>
<p>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</p>
</li>
<li>
<p>sql_thread 读取中转日志，解析出日志里的命令，并执行。</p>
</li>
</ol>
<h2 id="binlog-的三种格式对比">binlog 的三种格式对比</h2>
<p>binlog 有两种格式，一种是 statement，一种是 row。可能你在其他资料上还会看到有第三种格式，叫作 mixed，其实它就是前两种格式的混合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">delete</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="cm">/*comment*/</span><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="o">&gt;=</span><span class="mi">4</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">t_modified</span><span class="o">&lt;=</span><span class="s1">&#39;2018-11-10&#39;</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>通过这个sql语句看binlog：</p>
<p>当 binlog_format=<strong>statement</strong> 时，binlog 里面记录的就是 SQL 语句的原文。
当sql语句在从库执行的时候可能删除的是另外一行，因为从库执行是使用的索引可能会不一致。</p>
<p><strong>row</strong> 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p>
<ul>
<li>
<p>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</p>
</li>
<li>
<p>Delete_rows event，用于定义删除的行为。</p>
</li>
</ul>
<p>binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id=4 的行，不会有主备删除不同行的问题。</p>
<p>MySQL 就取了个折中方案，也就是有了 **mixed **格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</p>
<p>现在越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。这么做的理由有很多，我来给你举一个可以直接看出来的好处：恢复数据。</p>
<h1 id="服务端返回数据">服务端返回数据</h1>
<p>取数据和发数据的流程是这样的：</p>
<ol>
<li>
<p>获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k。</p>
</li>
<li>
<p>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</p>
</li>
<li>
<p>如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</p>
</li>
<li>
<p>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</p>
</li>
</ol>
<p>也就是说，MySQL 是“<code>边读边发的</code>”，这个概念很重要。这就意味着，如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间变长。</p>
<h1 id="join">join</h1>
<h2 id="index-nested-loop-join">Index Nested-Loop Join</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">t1</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">b</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">a</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>t1和t2一样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">a</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>在这个语句里，强制t1 是驱动表，t2 是被驱动表。
被驱动表 t2 的字段 a 上有索引，join 过程用上了这个索引。这个语句的执行流程是这样的：</p>
<ol>
<li>
<p>从表 t1 中读入一行数据 R；</p>
</li>
<li>
<p>从数据行 R 中，取出 a 字段到表 t2 里去查找；</p>
</li>
<li>
<p>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</p>
</li>
<li>
<p>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</p>
</li>
</ol>
<p>这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称 NLJ。</p>
<p>结论：
使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</p>
<p>如果使用 join 语句的话，需要让小表做驱动表。</p>
<p>但是，你需要注意，<strong>这个结论的前提是“可以使用被驱动表的索引”。</strong></p>
<h2 id="simple-nested-loop-join">Simple Nested-Loop Join</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>表 t2 的字段 b 上没有索引，因此再用图 2 的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>
<p>如果只看结果的话，这个算法是正确的，而且这个算法也有一个名字，叫做“Simple Nested-Loop Join”。</p>
<p>如果 t1 和 t2 都是 10 万行的表（当然了，这也还是属于小表的范围），就要扫描 100 亿行，这个算法看上去太“笨重”了。</p>
<p>当然，MySQL 也没有使用这个 Simple Nested-Loop Join 算法，而是使用了另一个叫作“Block Nested-Loop Join”的算法，简称 BNL。</p>
<h2 id="block-nested-loop-join">Block Nested-Loop Join</h2>
<p>被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol>
<li>
<p>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</p>
</li>
<li>
<p>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</p>
</li>
</ol>
<p>通过explain可以看到extra列中写的是useing join buffer(block nested loop)</p>
<p>对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。</p>
<p>如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。因此，从时间复杂度上来说，这两个算法是一样的。但是，Block Nested-Loop Join 算法的这 10 万次判断是<strong>内存操作</strong>，速度上会快很多，性能也更好。</p>
<p>这个例子里表 t1 才 100 行，要是表 t1 是一个大表，join_buffer 放不下怎么办呢？</p>
<p><strong>join_buffer</strong> 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1 的所有数据话，策略很简单，就是分段放。</p>
<p>执行过程就变成了：</p>
<ol>
<li>
<p>扫描表 t1，顺序读取数据行放入 join_buffer 中，放完第 88 行 join_buffer 满了，继续第 2 步；</p>
</li>
<li>
<p>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</p>
</li>
<li>
<p>清空 join_buffer；</p>
</li>
<li>
<p>继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</p>
</li>
</ol>
<p>这个流程才体现出了这个算法名字中“Block”的由来，表示“分块去 join”。</p>
<p>join_buffer_size 越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。你可能会看到一些建议告诉你，如果你的 join 语句很慢，就把 join_buffer_size 改大。</p>
<p>此种情形，大表还是小表做驱动表好呢？</p>
<p>假设驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。</p>
<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<p>扫描行数是 N+λ<em>N</em>M；</p>
<p>内存判断 N*M 次。</p>
<p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在 M 和 N 大小确定的情况下，N 小一些，整个算式的结果会更小。应该让小表当驱动表。</p>
<p>总结：
<strong>能不能使用 join 语句？</strong></p>
<p>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</p>
<p>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</p>
<p><strong>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</strong></p>
<p>如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表；</p>
<p>如果是 Block Nested-Loop Join 算法：</p>
<p>在 join_buffer_size 足够大的时候，是一样的；
在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。</p>
<h2 id="multi-range-read-优化">Multi-Range Read 优化</h2>
<p>回表是指，InnoDB 在普通索引 a 上查到主键 id 的值后，再根据一个个主键 id 的值到主键索引上去查整行数据的过程。</p>
<p>回表过程是一行行地查数据，还是批量地查数据？</p>
<p>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。虽然“按行查”这个机制不能改，但是调整查询的顺序，还是能够加速的。</p>
<p>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p>
<p>这，就是 MRR 优化的设计思路。</p>
<p>语句的执行流程变成了这样：</p>
<ol>
<li>
<p>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</p>
</li>
<li>
<p>将 read_rnd_buffer 中的 id 进行递增排序；</p>
</li>
<li>
<p>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</p>
</li>
</ol>
<p>这里，read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。
如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>
<h1 id="自增主键">自增主键</h1>
<h2 id="自增值修改机制">自增值修改机制</h2>
<p>show create table中AUTO_INCREMENT表示下次插入时主键的值。</p>
<p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<p>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</p>
<p>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</p>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ul>
<li>
<p>如果 X&lt;Y，那么这个表的自增值不变；</p>
</li>
<li>
<p>如果 X≥Y，就需要把当前自增值修改为新的自增值。</p>
</li>
</ul>
<p>新的自增值生成算法是：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</p>
<h2 id="自增值的修改时机">自增值的修改时机</h2>
<p>这个表的自增值改成 3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键 c 冲突，所以 id=2 这一行并没有插入成功，<strong>但也没有将自增值再改回去。</strong></p>
<h1 id="row_idxidtx_id">row_id,Xid,tx_id</h1>
<h2 id="innodb-系统自增-row_id">InnoDB 系统自增 row_id</h2>
<p>如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。</p>
<p>InnoDB 维护了一个<strong>全局的</strong> dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。</p>
<p>row_id 写入表中的值范围，是从 0 到 2^48-1；</p>
<p>当 dict_sys.row_id=248时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。</p>
<blockquote>
<p>在 InnoDB 逻辑里，申请到 row_id=N 后，就将这行数据写入表中；如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。</p>
</blockquote>
<p>从这个角度看，我们还是应该在 InnoDB 表中主动创建自增主键。因为，表自增 id 到达上限后，再插入数据时报主键冲突错误，是更能被接受的。</p>
<p><code>没有指定自增主键，到达上限会覆盖；指定主键后到达上限再插入会报主键冲突。</code></p>
<h2 id="xid">Xid</h2>
<p>介绍 redo log 和 binlog 相配合的时候，提到了它们有一个共同的字段叫作 Xid。它在 MySQL 中是用来对应事务的。</p>
<p>那么，Xid 在 MySQL 内部是怎么生成的呢？</p>
<p>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。</p>
<p>而 global_query_id 是一个纯内存变量，重启之后就清零了。所以你就知道了，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。</p>
<h2 id="innodb-trx_id">Innodb trx_id</h2>
<p>Xid 和 InnoDB 的 trx_id 是两个容易混淆的概念。</p>
<p>Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。</p>
<p>InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。</p>
<p>InnoDB 数据可见性的核心思想是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。
对于正在执行的事务，你可以从 information_schema.innodb_trx 表中看到事务的 trx_id。</p>
<h2 id="thread_id">thread_id</h2>
<p>接下来，我们再看看线程 id（thread_id）。其实，线程 id 才是 MySQL 中最常见的一种自增 id。平时我们在查各种现场的时候，show processlist 里面的第一列，就是 thread_id。</p>
<p>thread_id 的逻辑很好理解：系统保存了一个全局变量 thread_id_counter，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。</p>
<h1 id="案例">案例</h1>
<h2 id="先插入再更新阻塞">先插入、再更新阻塞</h2>
<p>先插入一条记录并不提交，另一个事务更新会阻塞</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">age</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>insert user (name,age) value(&ldquo;x&rdquo;,2);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td></td>
<td>update user set name = &lsquo;bb&rsquo; where age = 2;//阻塞</td>
</tr>
</tbody>
</table>
<p>为啥会阻塞？</p>
<p><code>InnoDb 在插入记录时，是不加锁的。</code>如果事务 A 插入记录且未提交，这时事务 B 尝试对这条记录加锁，事务 B 会<code>先去判断记录上保存的事务 id 是否活跃</code>，如果活跃的话，那么就帮助事务 A 去建立一个锁对象，然后自身进入等待事务 A 状态，这就是所谓的隐式锁转换为显式锁。</p>
<p>问题的脉络已经很清晰了：</p>
<ol>
<li>
<p>执行 insert 语句，判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁；</p>
</li>
<li>
<p>执行 select &hellip; lock in share mode 语句，判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列；</p>
</li>
</ol>
<h2 id="先插入后提交再更新-重复读结果不一样">先插入后提交、再更新 重复读结果不一样</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="n">AUTO_INCREMENT</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">name</span><span class="o">`</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="o">`</span><span class="n">age</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><table>
<thead>
<tr>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;</td>
<td>begin;</td>
</tr>
<tr>
<td>select * from user where age = 2; //无数据</td>
<td>select * from user where age = 2; //无数据</td>
</tr>
<tr>
<td>insert user (name,age) value(&ldquo;x&rdquo;,2);</td>
<td></td>
</tr>
<tr>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update user set name = &lsquo;bb&rsquo; where age = 2; //却更新到了一行，因为的更新是先读再更新，而且这个读是当前读，并把这条记录的最新的row trx_id更新了</td>
</tr>
<tr>
<td></td>
<td>select * from user where age = 2; //查到了一行，两次select不一致，因为上个update语句，这个时候读是能感知到当前事务的变化的，因为它能读到当前刚更新的row trx_id快照</td>
</tr>
<tr>
<td></td>
<td>commit;</td>
</tr>
</tbody>
</table>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-01-20</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/mysql/">mysql</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/docker_%E7%B3%BB%E7%BB%9F%E5%AD%A6docker%E7%AC%94%E8%AE%B0/" class="prev" rel="prev" title="系统学docker笔记"><i class="fas fa-angle-left fa-fw"></i>系统学docker笔记</a>
            <a href="/posts/mysql_%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/" class="next" rel="next" title="mysql是怎么运行的笔记">mysql是怎么运行的笔记<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2021-01-20T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"mysql实战45讲笔记"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
