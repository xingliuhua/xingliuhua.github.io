<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>趣谈linux笔记 - xlh博客</title><meta name="Description" content="趣谈linux笔记"><meta property="og:title" content="趣谈linux笔记" />
<meta property="og:description" content="趣谈linux笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0/" />
<meta property="og:image" content="https://xingliuhua.github.io/logo.png"/>
<meta property="article:published_time" content="2021-08-23T17:55:28+08:00" />
<meta property="article:modified_time" content="2021-08-23T17:55:28+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="趣谈linux笔记"/>
<meta name="twitter:description" content="趣谈linux笔记"/>
<meta name="application-name" content="xlh博客">
<meta name="apple-mobile-web-app-title" content="xlh博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0/" /><link rel="prev" href="https://xingliuhua.github.io/posts/linux_%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/" /><link rel="next" href="https://xingliuhua.github.io/posts/go_%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "趣谈linux笔记",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0\/"
        },"genre": "posts","keywords": "linux","wordcount":  8111 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0\/","datePublished": "2021-08-23T17:55:28+08:00","dateModified": "2021-08-23T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "趣谈linux笔记"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xlh博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xlh博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">趣谈linux笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-08-23">2021-08-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8111 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li><a href="#top命令">top命令</a></li>
    <li><a href="#uptime命令查看平均负载">uptime命令查看平均负载</a>
      <ol>
        <li><a href="#平均负载为多少时合理">平均负载为多少时合理</a></li>
        <li><a href="#平均负载与-cpu-使用率区别">平均负载与 CPU 使用率区别</a></li>
      </ol>
    </li>
    <li><a href="#uptime总结">uptime总结</a></li>
    <li><a href="#sysstat工具集">Sysstat工具集</a>
      <ol>
        <li><a href="#mpstat处理器统计信息">mpstat处理器统计信息</a></li>
        <li><a href="#pidstat进程和内核线程的统计信息">pidstat进程和内核线程的统计信息</a></li>
        <li><a href="#iostat块设备及其分区的-io-统计信息">iostat块设备及其分区的 IO 统计信息</a></li>
        <li><a href="#sar-工具">sar 工具；</a></li>
      </ol>
    </li>
    <li><a href="#上下文切换">上下文切换</a>
      <ol>
        <li><a href="#进程上下文切换">进程上下文切换</a>
          <ol>
            <li><a href="#进程的系统调用引起的cpu上下文切换">进程的系统调用引起的cpu上下文切换</a></li>
            <li><a href="#进程的上下文切换和系统调用">进程的上下文切换和系统调用</a></li>
            <li><a href="#进程什么时候上下文切换">进程什么时候上下文切换</a></li>
          </ol>
        </li>
        <li><a href="#线程的上下文切换">线程的上下文切换</a></li>
        <li><a href="#中断上下文切换">中断上下文切换</a></li>
        <li><a href="#查看系统的上下文切换情况">查看系统的上下文切换情况</a></li>
      </ol>
    </li>
    <li><a href="#cpu使用率">cpu使用率</a></li>
    <li><a href="#进程的状态">进程的状态</a></li>
    <li><a href="#进程间通信">进程间通信</a>
      <ol>
        <li><a href="#管道模型">管道模型</a></li>
        <li><a href="#消息队列">消息队列</a></li>
        <li><a href="#共享内存">共享内存</a></li>
        <li><a href="#信号">信号</a>
          <ol>
            <li><a href="#信号的发送">信号的发送</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#网络">网络</a>
      <ol>
        <li><a href="#发送数据包">发送数据包</a></li>
      </ol>
    </li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h1 id="top命令">top命令</h1>
<p>经常用来监控linux的系统状况，比如cpu、内存的使用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic1.png"
        data-srcset="./pic1.png, ./pic1.png 1.5x, ./pic1.png 2x"
        data-sizes="auto"
        alt="./pic1.png"
        title="./pic1.png" /></p>
<p>第一行：
跟uptime的内容一样。平均负载信息。</p>
<p>第二行：
Tasks — 任务（进程），系统现在共有135个进程，其中处于运行中的有1个，134个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p>第三行：cpu状态，我们可以看出有多少个逻辑cpu</p>
<p>0.3% us — 用户空间占用CPU的百分比。</p>
<p>0.0% sy — 内核空间占用CPU的百分比。
0.0% ni — 改变过优先级的进程占用CPU的百分比
99.7% id — 空闲CPU百分比
0.0% wa — IO等待占用CPU的百分比
0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
0.0% si — 软中断（Software Interrupts）占用CPU的百分比</p>
<p>第四行：内存状态，跟free功能类似
3808060k total — 物理内存总量（4GB）
3660048k used — 使用中的内存总量（3.6GB）
148012k free — 空闲内存总量（148M）
359760k buffers — 缓存的内存量 （359M）</p>
<p>第五行：swap交换分区
4184924k total — 交换区总量（4G）
0k used — 使用的交换区总量（0M）
4184924k free — 空闲交换区总量（4G）
2483956k cached — 缓冲的交换区总量（2483M）</p>
<p>第七行以下：各进程（任务）的状态监控
PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）</p>
<h1 id="uptime命令查看平均负载">uptime命令查看平均负载</h1>
<p>uptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。</p>
<p>那么什么是系统平均负载呢？ 平均负载是指单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。</p>
<p>所谓<strong>可运行状态</strong>的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p>
<p><strong>不可中断状态</strong>的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p>
<h2 id="平均负载为多少时合理">平均负载为多少时合理</h2>
<p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？</p>
<p>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。          <br>
在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</p>
<p>平均负载最理想的情况是等于 CPU 个数。所以在评判平均负载时， 首先你要知道系统有几个 CPU ，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取。</p>
<p>在我看来，当<code>平均负载高于 CPU 数量 70% </code>的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p>
<h2 id="平均负载与-cpu-使用率区别">平均负载与 CPU 使用率区别</h2>
<p>可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？        <br>
我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了                         正在使用 CPU                        的进程，还包括                         等待 CPU                        和                         等待 I/O                        的进程。        <br>
而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：        <br>
CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；          <br>
I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；          <br>
大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p>
<h1 id="uptime总结">uptime总结</h1>
<p>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p>
<ul>
<li>平均负载高有可能是 CPU 密集型进程导致的；</li>
<li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li>
<li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li>
</ul>
<h1 id="sysstat工具集">Sysstat工具集</h1>
<p>Sysstat 是一个软件包，包含监测系统性能及效率的一组工具，这些工具对于我们收集系统性能数据，比如CPU使用率、硬盘和网络吞吐数据，这些数据的收集和分析，有 利于我们判断系统是否正常运行，是提高系统运行效率、安全运行服务器的得力助手；
Sysstat 软件包集成如下工具：</p>
<ul>
<li>iostat 工具提供CPU使用率及硬盘吞吐效率的数据；</li>
<li>mpstat 工具提供单个处理器或多个处理器相关数据；</li>
<li>sar 工具负责收集、报告并存储系统活跃的信息；</li>
<li>sa1 工具负责收集并存储每天系统动态信息到一个二进制的文件中。它是通过计划任务工具cron来运行，
是为sadc所设计的程序前端程序；</li>
<li>sa2 工具负责把每天的系统活跃性息写入总结性的报告中。它是为sar所设计的前端 ，要通过cron来调用</li>
<li>sadc 是系统动态数据收集工具，收集的数据被写一个二进制的文件中，它被用作sar工具的后端；</li>
<li>sadf 显示被sar通过多种格式收集的数据；</li>
</ul>
<h2 id="mpstat处理器统计信息">mpstat处理器统计信息</h2>
<p>1.不带任何参数的使用mpstat命令将会输出所有CPU的平均统计信息</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ mpstat 
Linux 4.4.0-132-generic   08/31/2021      _x86_64_        <span class="o">(</span><span class="m">2</span> CPU<span class="o">)</span>

02:08:55 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
02:08:55 PM  all    7.14    0.00    1.08    0.34    0.00    0.10    0.00    0.00    0.00   91.34

</code></pre></div><h2 id="pidstat进程和内核线程的统计信息">pidstat进程和内核线程的统计信息</h2>
<p>该命令是用于监控进程和当前受内核管理的线程。pidstat还可以检查子进程和线程的状态。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"> pidstat 
Linux 4.4.0-132-generic    08/31/2021      _x86_64_        <span class="o">(</span><span class="m">2</span> CPU<span class="o">)</span>

02:11:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
02:11:03 PM     <span class="m">0</span>         <span class="m">1</span>    0.00    0.00    0.00    0.00     <span class="m">1</span>  systemd
02:11:03 PM     <span class="m">0</span>         <span class="m">2</span>    0.00    0.00    0.00    0.00     <span class="m">1</span>  kthreadd
02:11:03 PM     <span class="m">0</span>         <span class="m">3</span>    0.00    0.00    0.00    0.00     <span class="m">0</span>  ksoftirqd/0
02:11:03 PM     <span class="m">0</span>         <span class="m">7</span>    0.00    0.04    0.00    0.04     <span class="m">0</span>  rcu_sched

</code></pre></div><h2 id="iostat块设备及其分区的-io-统计信息">iostat块设备及其分区的 IO 统计信息</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ iostat 
Linux 4.4.0-132-generic   08/31/2021      _x86_64_        <span class="o">(</span><span class="m">2</span> CPU<span class="o">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           7.14    0.00    1.18    0.34    0.00   91.34

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               2.34         2.78        52.49  <span class="m">113137895</span> <span class="m">2136757300</span>
vdb              10.66        10.50       189.38  <span class="m">427285083</span> <span class="m">7708672664</span>

</code></pre></div><h2 id="sar-工具">sar 工具；</h2>
<p>sar 工具比较强大，既能收集系统CPU、硬盘、动态数据，也能显示动态显示，更能查看二进制数据文件；sar 的应用比较多，而且也比较复杂，数据更为精确。
示例：查看cpu使用率</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sar -u  <span class="m">1</span> <span class="m">5</span>
Linux 2.6.15-1.2054_FC5 <span class="o">(</span>localhost.localdomain<span class="o">)</span>         2006年05月12日

时间              CPU    利用率    nice值    系统占用    IO占用  空闲
11时19分34秒       CPU     %user     %nice   %system   %iowait     %idle
11时19分35秒       all      2.97      0.00      0.00      0.00     97.03
11时19分36秒       all     11.11      0.00      9.09      0.00     79.80
11时19分37秒       all     21.78      0.00      6.93      0.00     71.29
11时19分38秒       all     15.00      0.00      0.00      0.00     85.00
11时19分39秒       all      8.00      0.00      0.00      0.00     92.00
Average:          all     11.78      0.00      3.19      0.00     85.03
注解：

CPU：表示机器内所有的CPU；
%user 表示CPU的利用率；
%nice 表示CPU在用户层优先级的百分比，0表示正常；
%system 表示当系统运行时，在用户应用层上所占用的CPU百分比；
%iowait 表示请求硬盘I/0数据流出时，所占用CPU的百分比；
%idle 表示空闲CPU百分比，值越大系统负载越低；
</code></pre></div><h1 id="上下文切换">上下文切换</h1>
<p>每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好<strong>CPU 寄存器</strong>和<strong>程序计数器</strong>Program Counter，PC）。</p>
<p>CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做<strong>CPU 上下文</strong>。</p>
<p>硬件通过触发信号，会导致中断处理程序的调用，也是一种常见的任务。        <br>
所以，根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是<strong>进程上下文切换</strong>、<strong>线程上下文切换</strong>以及<strong>中断上下文切换</strong>。</p>
<h2 id="进程上下文切换">进程上下文切换</h2>
<p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p>
<p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；          <br>
用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</p>
<p>换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。        <br>
从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p>
<h3 id="进程的系统调用引起的cpu上下文切换">进程的系统调用引起的cpu上下文切换</h3>
<p>那么，系统调用的过程有没有发生 CPU 上下文的切换呢？答案自然是肯定的。        <br>
CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。        <br>
而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</p>
<p>不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：        <br>
进程上下文切换，是指从一个进程切换到另一个进程运行。          <br>
而系统调用过程中一直是同一个进程在运行。          <br>
所以，系统调用过程通常称为<strong>特权模式切换</strong>，而不是上下文切换。但实际上，<code>系统调用过程中，CPU 的上下文切换还是无法避免的</code>。</p>
<h3 id="进程的上下文切换和系统调用">进程的上下文切换和系统调用</h3>
<p>那么，进程上下文切换跟系统调用又有什么区别呢？        <br>
首先，你需要知道，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，<code>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</code>。        <br>
因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要<code>先把该进程的虚拟内存、栈等保存下来</code>；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p>在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</p>
<h3 id="进程什么时候上下文切换">进程什么时候上下文切换</h3>
<p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照<code>优先级和等待 CPU 的时间排序</code>，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。
进程在什么时候才会被调度到 CPU 上运行：
其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。        <br>
其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。        <br>
其三，当进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度。        <br>
其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。        <br>
最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。        <br>
了解这几个场景是非常有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后凶手。</p>
<h2 id="线程的上下文切换">线程的上下文切换</h2>
<p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，<code>所谓内核中的任务调度，实际上的调度对象是线程</code>；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：        <br>
当进程只有一个线程时，可以认为进程就等于线程。          <br>
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。          <br>
另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>
<p>线程的上下文切换其实就可以分为两种情况：        <br>
第一种， 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。        <br>
第二种，前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p>
<p>到这里你应该也发现了，虽然<code>同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源</code>，而这，也正是多线程代替多进程的一个优势。</p>
<h2 id="中断上下文切换">中断上下文切换</h2>
<p>除了前面两种上下文切换，还有一个场景也会切换 CPU 上下文，那就是中断。</p>
<p>跟进程上下文不同，<code>中断上下文切换并不涉及到进程的用户态</code>。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。        <br>
另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。</p>
<h2 id="查看系统的上下文切换情况">查看系统的上下文切换情况</h2>
<p>通过前面学习我们知道，过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成了系统性能大幅下降的一个元凶。
可以使用 vmstat 这个工具，来查询系统的上下文切换情况。vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</p>
<p>下面就是一个 vmstat 的使用示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">1# 每隔 <span class="m">5</span> 秒输出 <span class="m">1</span> 组数据
2$ vmstat <span class="m">5</span>
3procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
<span class="m">4</span> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
<span class="m">5</span> <span class="m">0</span>  <span class="m">0</span>      <span class="m">0</span> <span class="m">7005360</span>  <span class="m">91564</span> <span class="m">818900</span>    <span class="m">0</span>    <span class="m">0</span>     <span class="m">0</span>     <span class="m">0</span>   <span class="m">25</span>   <span class="m">33</span>  <span class="m">0</span>  <span class="m">0</span> <span class="m">100</span>  <span class="m">0</span>
</code></pre></div><p>cs（context switch）是每秒上下文切换的次数。          <br>
in（interrupt）则是每秒中断的次数。          <br>
r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。          <br>
b（Blocked）则是处于不可中断睡眠状态的进程数。</p>
<p>vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat  了。给它加上 -w 选项</p>
<p>这个结果中有两列内容是我们的重点关注对象。一个是  cswch  ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是  nvcswch  ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。        <br>
这两个概念你一定要牢牢记住，因为它们意味着不同的性能问题：        <br>
所谓<strong>自愿上下文切换</strong>，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。          <br>
而<strong>非自愿上下文切换</strong>，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</p>
<h1 id="cpu使用率">cpu使用率</h1>
<p>计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率，即</p>
<h1 id="进程的状态">进程的状态</h1>
<p>top 和 ps 是最常用的查看进程状态的工具，我们就从 top 的输出开始。下面是一个 top 命令输出的示例，S 列（也就是 Status  列）表示进程的状态。从这个示例里，你可以看到 R、D、Z、S、I 等几个状态，
R 是Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。          <br>
D 是Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。          <br>
Z 是Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。          <br>
S 是Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。          <br>
I 是Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。
X 也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。
T 或者t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。</p>
<h1 id="进程间通信">进程间通信</h1>
<h2 id="管道模型">管道模型</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ps -ef <span class="p">|</span> grep 关键字 <span class="p">|</span> awk <span class="s1">&#39;{print $2}&#39;</span> <span class="p">|</span> xargs <span class="nb">kill</span> -9
</code></pre></div><p>它会将前一个命令的输出，作为后一个命令的输入。从管道的这个名称可以看出来，管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行</p>
<p>管道分为两种类型，“|” 表示的管道称为匿名管道，意思就是这个类型的管道没有名字，用完了就销毁了。</p>
<p>另外一种类型是命名管道。这个类型的管道需要通过 mkfifo 命令显式地创建。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">mkfifo hello
<span class="c1"># ls -l</span>
prw-r--r--  <span class="m">1</span> root root         <span class="m">0</span> May <span class="m">21</span> 23:29 hello
</code></pre></div><h2 id="消息队列">消息队列</h2>
<p>创建一个消息队列，使用msgget 函数。发送消息主要调用msgsnd 函数。收消息主要调用msgrcv 函数。</p>
<h2 id="共享内存">共享内存</h2>
<p>拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p>
<p>需要一种保护机制，使得同一个共享的资源，同时只能被一个进程访问。在 System V IPC 进程间通信机制体系中，早就想好了应对办法，就是信号量（Semaphore）。因此，信号量和共享内存往往要配合使用。</p>
<h2 id="信号">信号</h2>
<p>信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。</p>
<p>一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p>1.执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 Term，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p>
<p>2.捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p>3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。</p>
<h3 id="信号的发送">信号的发送</h3>
<p>有时候，我们在终端输入某些组合键的时候，会给进程发送信号，例如，Ctrl+C 产生 SIGINT 信号，Ctrl+Z 产生 SIGTSTP 信号</p>
<h1 id="网络">网络</h1>
<p>应用层和内核互通的机制，就是通过 Socket 系统调用。所以经常有人会问，Socket 属于哪一层，其实它哪一层都不属于，它属于操作系统的概念，而非网络协议分层的概念。只不过操作系统选择对于网络协议的实现模式是，二到四层的处理代码在内核里面，七层的处理代码让应用自己去做，两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是 Socket。</p>
<h2 id="发送数据包">发送数据包</h2>
<p>网络分完层之后，对于数据包的发送，就是层层封装的过程。在 Linux 服务器 B 上部署的服务端 Nginx 和 Tomcat，都是通过 Socket 监听 80 和 8080 端口。这个时候，内核的数据结构就知道了。如果遇到发送到这两个端口的，就发送给这两个进程。</p>
<p>在 Linux 服务器 A 上的客户端，打开一个 Firefox 连接 Ngnix。也是通过 Socket，客户端会被分配一个随机端口 12345。同理，打开一个 Chrome 连接 Tomcat，同样通过 Socket 分配随机端口 12346。</p>
<p>在传输层有两个主流的协议 TCP 和 UDP，所以我们的 socket 程序设计也是主要操作这两个协议。这两个协议的区别是什么呢？通常的答案是下面这样的。</p>
<ul>
<li>TCP 是面向连接的，UDP 是面向无连接的。</li>
<li>TCP 提供可靠交付，无差错、不丢失、不重复、并且按序到达；UDP 不提供可靠交付，不保证不丢失，不保证按顺序到达。</li>
<li>TCP 是面向字节流的，发送时发的是一个流，没头没尾；UDP 是面向数据报的，一个一个的发送。</li>
<li>TCP 是可以提供流量控制和拥塞控制的，既防止对端被压垮，也防止网络被压垮。</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-08-23</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux/">linux</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/linux_%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/" class="prev" rel="prev" title="linux软连接和硬连接"><i class="fas fa-angle-left fa-fw"></i>linux软连接和硬连接</a>
            <a href="/posts/go_%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="next" rel="next" title="golang 结构体内存对齐">golang 结构体内存对齐<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2021-08-23T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"趣谈linux笔记"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
