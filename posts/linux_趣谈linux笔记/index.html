<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>趣谈linux笔记 - xingliuhua博客</title><meta name="Description" content="趣谈linux笔记"><meta property="og:title" content="趣谈linux笔记" />
<meta property="og:description" content="趣谈linux笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0/" /><meta property="og:image" content="https://xingliuhua.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-23T17:55:28+08:00" />
<meta property="article:modified_time" content="2021-08-23T17:55:28+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="趣谈linux笔记"/>
<meta name="twitter:description" content="趣谈linux笔记"/>
<meta name="application-name" content="xingliuhua博客">
<meta name="apple-mobile-web-app-title" content="xingliuhua博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0/" /><link rel="prev" href="https://xingliuhua.github.io/posts/linux_%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/" /><link rel="next" href="https://xingliuhua.github.io/posts/go_%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "趣谈linux笔记",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0\/"
        },"genre": "posts","keywords": "linux","wordcount":  8111 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/linux_%E8%B6%A3%E8%B0%88linux%E7%AC%94%E8%AE%B0\/","datePublished": "2021-08-23T17:55:28+08:00","dateModified": "2021-08-23T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "趣谈linux笔记"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">趣谈linux笔记</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-08-23">2021-08-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8111 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li><a href="#top命令">top命令</a></li>
    <li><a href="#uptime命令查看平均负载">uptime命令查看平均负载</a>
      <ol>
        <li><a href="#平均负载为多少时合理">平均负载为多少时合理</a></li>
        <li><a href="#平均负载与-cpu-使用率区别">平均负载与 CPU 使用率区别</a></li>
      </ol>
    </li>
    <li><a href="#uptime总结">uptime总结</a></li>
    <li><a href="#sysstat工具集">Sysstat工具集</a>
      <ol>
        <li><a href="#mpstat处理器统计信息">mpstat处理器统计信息</a></li>
        <li><a href="#pidstat进程和内核线程的统计信息">pidstat进程和内核线程的统计信息</a></li>
        <li><a href="#iostat块设备及其分区的-io-统计信息">iostat块设备及其分区的 IO 统计信息</a></li>
        <li><a href="#sar-工具">sar 工具；</a></li>
      </ol>
    </li>
    <li><a href="#上下文切换">上下文切换</a>
      <ol>
        <li><a href="#进程上下文切换">进程上下文切换</a>
          <ol>
            <li><a href="#进程的系统调用引起的cpu上下文切换">进程的系统调用引起的cpu上下文切换</a></li>
            <li><a href="#进程的上下文切换和系统调用">进程的上下文切换和系统调用</a></li>
            <li><a href="#进程什么时候上下文切换">进程什么时候上下文切换</a></li>
          </ol>
        </li>
        <li><a href="#线程的上下文切换">线程的上下文切换</a></li>
        <li><a href="#中断上下文切换">中断上下文切换</a></li>
        <li><a href="#查看系统的上下文切换情况">查看系统的上下文切换情况</a></li>
      </ol>
    </li>
    <li><a href="#cpu使用率">cpu使用率</a></li>
    <li><a href="#进程的状态">进程的状态</a></li>
    <li><a href="#进程间通信">进程间通信</a>
      <ol>
        <li><a href="#管道模型">管道模型</a></li>
        <li><a href="#消息队列">消息队列</a></li>
        <li><a href="#共享内存">共享内存</a></li>
        <li><a href="#信号">信号</a>
          <ol>
            <li><a href="#信号的发送">信号的发送</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#网络">网络</a>
      <ol>
        <li><a href="#发送数据包">发送数据包</a></li>
      </ol>
    </li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h1 id="top命令">top命令</h1>
<p>经常用来监控linux的系统状况，比如cpu、内存的使用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic1.png"
        data-srcset="./pic1.png, ./pic1.png 1.5x, ./pic1.png 2x"
        data-sizes="auto"
        alt="./pic1.png"
        title="./pic1.png" /></p>
<p>第一行：
跟uptime的内容一样。平均负载信息。</p>
<p>第二行：
Tasks — 任务（进程），系统现在共有135个进程，其中处于运行中的有1个，134个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<p>第三行：cpu状态，我们可以看出有多少个逻辑cpu</p>
<p>0.3% us — 用户空间占用CPU的百分比。</p>
<p>0.0% sy — 内核空间占用CPU的百分比。
0.0% ni — 改变过优先级的进程占用CPU的百分比
99.7% id — 空闲CPU百分比
0.0% wa — IO等待占用CPU的百分比
0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
0.0% si — 软中断（Software Interrupts）占用CPU的百分比</p>
<p>第四行：内存状态，跟free功能类似
3808060k total — 物理内存总量（4GB）
3660048k used — 使用中的内存总量（3.6GB）
148012k free — 空闲内存总量（148M）
359760k buffers — 缓存的内存量 （359M）</p>
<p>第五行：swap交换分区
4184924k total — 交换区总量（4G）
0k used — 使用的交换区总量（0M）
4184924k free — 空闲交换区总量（4G）
2483956k cached — 缓冲的交换区总量（2483M）</p>
<p>第七行以下：各进程（任务）的状态监控
PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）</p>
<h1 id="uptime命令查看平均负载">uptime命令查看平均负载</h1>
<p>uptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。</p>
<p>那么什么是系统平均负载呢？ 平均负载是指单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。</p>
<p>所谓<strong>可运行状态</strong>的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。</p>
<p><strong>不可中断状态</strong>的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。</p>
<h2 id="平均负载为多少时合理">平均负载为多少时合理</h2>
<p>既然平均的是活跃进程数，那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。比如当平均负载为 2 时，意味着什么呢？</p>
<p>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。          <br>
在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</p>
<p>平均负载最理想的情况是等于 CPU 个数。所以在评判平均负载时， 首先你要知道系统有几个 CPU ，这可以通过 top 命令或者从文件 /proc/cpuinfo 中读取。</p>
<p>在我看来，当<code>平均负载高于 CPU 数量 70% </code>的时候，你就应该分析排查负载高的问题了。一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。</p>
<h2 id="平均负载与-cpu-使用率区别">平均负载与 CPU 使用率区别</h2>
<p>可能你会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？        <br>
我们还是要回到平均负载的含义上来，平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数。所以，它不仅包括了                         正在使用 CPU                        的进程，还包括                         等待 CPU                        和                         等待 I/O                        的进程。        <br>
而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：        <br>
CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；          <br>
I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；          <br>
大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。</p>
<h1 id="uptime总结">uptime总结</h1>
<p>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p>
<ul>
<li>平均负载高有可能是 CPU 密集型进程导致的；</li>
<li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li>
<li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li>
</ul>
<h1 id="sysstat工具集">Sysstat工具集</h1>
<p>Sysstat 是一个软件包，包含监测系统性能及效率的一组工具，这些工具对于我们收集系统性能数据，比如CPU使用率、硬盘和网络吞吐数据，这些数据的收集和分析，有 利于我们判断系统是否正常运行，是提高系统运行效率、安全运行服务器的得力助手；
Sysstat 软件包集成如下工具：</p>
<ul>
<li>iostat 工具提供CPU使用率及硬盘吞吐效率的数据；</li>
<li>mpstat 工具提供单个处理器或多个处理器相关数据；</li>
<li>sar 工具负责收集、报告并存储系统活跃的信息；</li>
<li>sa1 工具负责收集并存储每天系统动态信息到一个二进制的文件中。它是通过计划任务工具cron来运行，
是为sadc所设计的程序前端程序；</li>
<li>sa2 工具负责把每天的系统活跃性息写入总结性的报告中。它是为sar所设计的前端 ，要通过cron来调用</li>
<li>sadc 是系统动态数据收集工具，收集的数据被写一个二进制的文件中，它被用作sar工具的后端；</li>
<li>sadf 显示被sar通过多种格式收集的数据；</li>
</ul>
<h2 id="mpstat处理器统计信息">mpstat处理器统计信息</h2>
<p>1.不带任何参数的使用mpstat命令将会输出所有CPU的平均统计信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ mpstat 
</span></span><span class="line"><span class="cl">Linux 4.4.0-132-generic   08/31/2021      _x86_64_        <span class="o">(</span><span class="m">2</span> CPU<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">02:08:55 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
</span></span><span class="line"><span class="cl">02:08:55 PM  all    7.14    0.00    1.08    0.34    0.00    0.10    0.00    0.00    0.00   91.34
</span></span></code></pre></div><h2 id="pidstat进程和内核线程的统计信息">pidstat进程和内核线程的统计信息</h2>
<p>该命令是用于监控进程和当前受内核管理的线程。pidstat还可以检查子进程和线程的状态。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> pidstat 
</span></span><span class="line"><span class="cl">Linux 4.4.0-132-generic    08/31/2021      _x86_64_        <span class="o">(</span><span class="m">2</span> CPU<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">02:11:03 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
</span></span><span class="line"><span class="cl">02:11:03 PM     <span class="m">0</span>         <span class="m">1</span>    0.00    0.00    0.00    0.00     <span class="m">1</span>  systemd
</span></span><span class="line"><span class="cl">02:11:03 PM     <span class="m">0</span>         <span class="m">2</span>    0.00    0.00    0.00    0.00     <span class="m">1</span>  kthreadd
</span></span><span class="line"><span class="cl">02:11:03 PM     <span class="m">0</span>         <span class="m">3</span>    0.00    0.00    0.00    0.00     <span class="m">0</span>  ksoftirqd/0
</span></span><span class="line"><span class="cl">02:11:03 PM     <span class="m">0</span>         <span class="m">7</span>    0.00    0.04    0.00    0.04     <span class="m">0</span>  rcu_sched
</span></span></code></pre></div><h2 id="iostat块设备及其分区的-io-统计信息">iostat块设备及其分区的 IO 统计信息</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ iostat 
</span></span><span class="line"><span class="cl">Linux 4.4.0-132-generic   08/31/2021      _x86_64_        <span class="o">(</span><span class="m">2</span> CPU<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">avg-cpu:  %user   %nice %system %iowait  %steal   %idle
</span></span><span class="line"><span class="cl">           7.14    0.00    1.18    0.34    0.00   91.34
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
</span></span><span class="line"><span class="cl">vda               2.34         2.78        52.49  <span class="m">113137895</span> <span class="m">2136757300</span>
</span></span><span class="line"><span class="cl">vdb              10.66        10.50       189.38  <span class="m">427285083</span> <span class="m">7708672664</span>
</span></span></code></pre></div><h2 id="sar-工具">sar 工具；</h2>
<p>sar 工具比较强大，既能收集系统CPU、硬盘、动态数据，也能显示动态显示，更能查看二进制数据文件；sar 的应用比较多，而且也比较复杂，数据更为精确。
示例：查看cpu使用率</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sar -u  <span class="m">1</span> <span class="m">5</span>
</span></span><span class="line"><span class="cl">Linux 2.6.15-1.2054_FC5 <span class="o">(</span>localhost.localdomain<span class="o">)</span>         2006年05月12日
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">时间              CPU    利用率    nice值    系统占用    IO占用  空闲
</span></span><span class="line"><span class="cl">11时19分34秒       CPU     %user     %nice   %system   %iowait     %idle
</span></span><span class="line"><span class="cl">11时19分35秒       all      2.97      0.00      0.00      0.00     97.03
</span></span><span class="line"><span class="cl">11时19分36秒       all     11.11      0.00      9.09      0.00     79.80
</span></span><span class="line"><span class="cl">11时19分37秒       all     21.78      0.00      6.93      0.00     71.29
</span></span><span class="line"><span class="cl">11时19分38秒       all     15.00      0.00      0.00      0.00     85.00
</span></span><span class="line"><span class="cl">11时19分39秒       all      8.00      0.00      0.00      0.00     92.00
</span></span><span class="line"><span class="cl">Average:          all     11.78      0.00      3.19      0.00     85.03
</span></span><span class="line"><span class="cl">注解：
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CPU：表示机器内所有的CPU；
</span></span><span class="line"><span class="cl">%user 表示CPU的利用率；
</span></span><span class="line"><span class="cl">%nice 表示CPU在用户层优先级的百分比，0表示正常；
</span></span><span class="line"><span class="cl">%system 表示当系统运行时，在用户应用层上所占用的CPU百分比；
</span></span><span class="line"><span class="cl">%iowait 表示请求硬盘I/0数据流出时，所占用CPU的百分比；
</span></span><span class="line"><span class="cl">%idle 表示空闲CPU百分比，值越大系统负载越低；
</span></span></code></pre></div><h1 id="上下文切换">上下文切换</h1>
<p>每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好<strong>CPU 寄存器</strong>和<strong>程序计数器</strong>Program Counter，PC）。</p>
<p>CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做<strong>CPU 上下文</strong>。</p>
<p>硬件通过触发信号，会导致中断处理程序的调用，也是一种常见的任务。        <br>
所以，根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是<strong>进程上下文切换</strong>、<strong>线程上下文切换</strong>以及<strong>中断上下文切换</strong>。</p>
<h2 id="进程上下文切换">进程上下文切换</h2>
<p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p>
<p>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；          <br>
用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</p>
<p>换个角度看，也就是说，进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。        <br>
从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p>
<h3 id="进程的系统调用引起的cpu上下文切换">进程的系统调用引起的cpu上下文切换</h3>
<p>那么，系统调用的过程有没有发生 CPU 上下文的切换呢？答案自然是肯定的。        <br>
CPU 寄存器里原来用户态的指令位置，需要先保存起来。接着，为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。最后才是跳转到内核态运行内核任务。        <br>
而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</p>
<p>不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：        <br>
进程上下文切换，是指从一个进程切换到另一个进程运行。          <br>
而系统调用过程中一直是同一个进程在运行。          <br>
所以，系统调用过程通常称为<strong>特权模式切换</strong>，而不是上下文切换。但实际上，<code>系统调用过程中，CPU 的上下文切换还是无法避免的</code>。</p>
<h3 id="进程的上下文切换和系统调用">进程的上下文切换和系统调用</h3>
<p>那么，进程上下文切换跟系统调用又有什么区别呢？        <br>
首先，你需要知道，进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，<code>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</code>。        <br>
因此，进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要<code>先把该进程的虚拟内存、栈等保存下来</code>；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p>
<p>在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</p>
<h3 id="进程什么时候上下文切换">进程什么时候上下文切换</h3>
<p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照<code>优先级和等待 CPU 的时间排序</code>，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。
进程在什么时候才会被调度到 CPU 上运行：
其一，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。        <br>
其二，进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。        <br>
其三，当进程通过睡眠函数  sleep 这样的方法将自己主动挂起时，自然也会重新调度。        <br>
其四，当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。        <br>
最后一个，发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。        <br>
了解这几个场景是非常有必要的，因为一旦出现上下文切换的性能问题，它们就是幕后凶手。</p>
<h2 id="线程的上下文切换">线程的上下文切换</h2>
<p>线程与进程最大的区别在于，<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，<code>所谓内核中的任务调度，实际上的调度对象是线程</code>；而进程只是给线程提供了虚拟内存、全局变量等资源。所以，对于线程和进程，我们可以这么理解：        <br>
当进程只有一个线程时，可以认为进程就等于线程。          <br>
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。          <br>
另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>
<p>线程的上下文切换其实就可以分为两种情况：        <br>
第一种， 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。        <br>
第二种，前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p>
<p>到这里你应该也发现了，虽然<code>同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源</code>，而这，也正是多线程代替多进程的一个优势。</p>
<h2 id="中断上下文切换">中断上下文切换</h2>
<p>除了前面两种上下文切换，还有一个场景也会切换 CPU 上下文，那就是中断。</p>
<p>跟进程上下文不同，<code>中断上下文切换并不涉及到进程的用户态</code>。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p>
<p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。        <br>
另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。</p>
<h2 id="查看系统的上下文切换情况">查看系统的上下文切换情况</h2>
<p>通过前面学习我们知道，过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成了系统性能大幅下降的一个元凶。
可以使用 vmstat 这个工具，来查询系统的上下文切换情况。vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。</p>
<p>下面就是一个 vmstat 的使用示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">1# 每隔 <span class="m">5</span> 秒输出 <span class="m">1</span> 组数据
</span></span><span class="line"><span class="cl">2$ vmstat <span class="m">5</span>
</span></span><span class="line"><span class="cl">3procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
</span></span><span class="line"><span class="cl"><span class="m">4</span> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
</span></span><span class="line"><span class="cl"><span class="m">5</span> <span class="m">0</span>  <span class="m">0</span>      <span class="m">0</span> <span class="m">7005360</span>  <span class="m">91564</span> <span class="m">818900</span>    <span class="m">0</span>    <span class="m">0</span>     <span class="m">0</span>     <span class="m">0</span>   <span class="m">25</span>   <span class="m">33</span>  <span class="m">0</span>  <span class="m">0</span> <span class="m">100</span>  <span class="m">0</span>
</span></span></code></pre></div><p>cs（context switch）是每秒上下文切换的次数。          <br>
in（interrupt）则是每秒中断的次数。          <br>
r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。          <br>
b（Blocked）则是处于不可中断睡眠状态的进程数。</p>
<p>vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat  了。给它加上 -w 选项</p>
<p>这个结果中有两列内容是我们的重点关注对象。一个是  cswch  ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是  nvcswch  ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。        <br>
这两个概念你一定要牢牢记住，因为它们意味着不同的性能问题：        <br>
所谓<strong>自愿上下文切换</strong>，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。          <br>
而<strong>非自愿上下文切换</strong>，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。</p>
<h1 id="cpu使用率">cpu使用率</h1>
<p>计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率，即</p>
<h1 id="进程的状态">进程的状态</h1>
<p>top 和 ps 是最常用的查看进程状态的工具，我们就从 top 的输出开始。下面是一个 top 命令输出的示例，S 列（也就是 Status  列）表示进程的状态。从这个示例里，你可以看到 R、D、Z、S、I 等几个状态，
R 是Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。          <br>
D 是Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。          <br>
Z 是Zombie 的缩写，如果你玩过“植物大战僵尸”这款游戏，应该知道它的意思。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。          <br>
S 是Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。          <br>
I 是Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。前面说了，硬件交互导致的不可中断进程用 D 表示，但对某些内核线程来说，它们有可能实际上并没有任何负载，用 Idle 正是为了区分这种情况。要注意，D 状态的进程会导致平均负载升高， I 状态的进程却不会。
X 也就是 Dead 的缩写，表示进程已经消亡，所以你不会在 top 或者 ps 命令中看到它。
T 或者t，也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。</p>
<h1 id="进程间通信">进程间通信</h1>
<h2 id="管道模型">管道模型</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ps -ef <span class="p">|</span> grep 关键字 <span class="p">|</span> awk <span class="s1">&#39;{print $2}&#39;</span> <span class="p">|</span> xargs <span class="nb">kill</span> -9
</span></span></code></pre></div><p>它会将前一个命令的输出，作为后一个命令的输入。从管道的这个名称可以看出来，管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行</p>
<p>管道分为两种类型，“|” 表示的管道称为匿名管道，意思就是这个类型的管道没有名字，用完了就销毁了。</p>
<p>另外一种类型是命名管道。这个类型的管道需要通过 mkfifo 命令显式地创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">mkfifo hello
</span></span><span class="line"><span class="cl"><span class="c1"># ls -l</span>
</span></span><span class="line"><span class="cl">prw-r--r--  <span class="m">1</span> root root         <span class="m">0</span> May <span class="m">21</span> 23:29 hello
</span></span></code></pre></div><h2 id="消息队列">消息队列</h2>
<p>创建一个消息队列，使用msgget 函数。发送消息主要调用msgsnd 函数。收消息主要调用msgrcv 函数。</p>
<h2 id="共享内存">共享内存</h2>
<p>拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去。</p>
<p>需要一种保护机制，使得同一个共享的资源，同时只能被一个进程访问。在 System V IPC 进程间通信机制体系中，早就想好了应对办法，就是信号量（Semaphore）。因此，信号量和共享内存往往要配合使用。</p>
<h2 id="信号">信号</h2>
<p>信号没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。信号之间依靠它们的值来区分。信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。</p>
<p>一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p>1.执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 Term，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</p>
<p>2.捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p>3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。</p>
<h3 id="信号的发送">信号的发送</h3>
<p>有时候，我们在终端输入某些组合键的时候，会给进程发送信号，例如，Ctrl+C 产生 SIGINT 信号，Ctrl+Z 产生 SIGTSTP 信号</p>
<h1 id="网络">网络</h1>
<p>应用层和内核互通的机制，就是通过 Socket 系统调用。所以经常有人会问，Socket 属于哪一层，其实它哪一层都不属于，它属于操作系统的概念，而非网络协议分层的概念。只不过操作系统选择对于网络协议的实现模式是，二到四层的处理代码在内核里面，七层的处理代码让应用自己去做，两者需要跨内核态和用户态通信，就需要一个系统调用完成这个衔接，这就是 Socket。</p>
<h2 id="发送数据包">发送数据包</h2>
<p>网络分完层之后，对于数据包的发送，就是层层封装的过程。在 Linux 服务器 B 上部署的服务端 Nginx 和 Tomcat，都是通过 Socket 监听 80 和 8080 端口。这个时候，内核的数据结构就知道了。如果遇到发送到这两个端口的，就发送给这两个进程。</p>
<p>在 Linux 服务器 A 上的客户端，打开一个 Firefox 连接 Ngnix。也是通过 Socket，客户端会被分配一个随机端口 12345。同理，打开一个 Chrome 连接 Tomcat，同样通过 Socket 分配随机端口 12346。</p>
<p>在传输层有两个主流的协议 TCP 和 UDP，所以我们的 socket 程序设计也是主要操作这两个协议。这两个协议的区别是什么呢？通常的答案是下面这样的。</p>
<ul>
<li>TCP 是面向连接的，UDP 是面向无连接的。</li>
<li>TCP 提供可靠交付，无差错、不丢失、不重复、并且按序到达；UDP 不提供可靠交付，不保证不丢失，不保证按顺序到达。</li>
<li>TCP 是面向字节流的，发送时发的是一个流，没头没尾；UDP 是面向数据报的，一个一个的发送。</li>
<li>TCP 是可以提供流量控制和拥塞控制的，既防止对端被压垮，也防止网络被压垮。</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-08-23</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux/">linux</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/linux_%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5/" class="prev" rel="prev" title="linux软连接和硬连接"><i class="fas fa-angle-left fa-fw"></i>linux软连接和硬连接</a>
            <a href="/posts/go_%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="next" rel="next" title="golang 结构体内存对齐">golang 结构体内存对齐<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2021-08-23T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"趣谈linux笔记"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
