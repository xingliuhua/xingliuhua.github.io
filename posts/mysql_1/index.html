<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>mysql基础 - xingliuhua博客</title><meta name="Description" content="mysql基础"><meta property="og:title" content="mysql基础" />
<meta property="og:description" content="mysql基础" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/mysql_1/" />
<meta property="og:image" content="https://xingliuhua.github.io/logo.png"/>
<meta property="article:published_time" content="2019-03-01T17:55:28+08:00" />
<meta property="article:modified_time" content="2019-03-01T17:55:28+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="mysql基础"/>
<meta name="twitter:description" content="mysql基础"/>
<meta name="application-name" content="xingliuhua博客">
<meta name="apple-mobile-web-app-title" content="xingliuhua博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/mysql_1/" /><link rel="prev" href="https://xingliuhua.github.io/posts/mysql_%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/" /><link rel="next" href="https://xingliuhua.github.io/posts/mysql_2/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "mysql基础",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/mysql_1\/"
        },"genre": "posts","keywords": "mysql","wordcount":  8656 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/mysql_1\/","datePublished": "2019-03-01T17:55:28+08:00","dateModified": "2019-03-01T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "mysql基础"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">mysql基础</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2019-03-01">2019-03-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8656 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 18 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li>
          <ol>
            <li><a href="#概述">概述</a></li>
            <li><a href="#数据引擎">数据引擎</a></li>
            <li><a href="#字符集">字符集</a></li>
            <li><a href="#数据类型">数据类型</a>
              <ol>
                <li><a href="#整数">整数</a></li>
                <li><a href="#小数">小数</a></li>
                <li><a href="#日期时间">日期时间</a></li>
                <li><a href="#字符串">字符串</a></li>
                <li><a href="#二进制">二进制</a></li>
                <li><a href="#数据类型的选择">数据类型的选择</a></li>
              </ol>
            </li>
            <li><a href="#数据库基本操作">数据库基本操作</a></li>
            <li><a href="#数据表的基本操作">数据表的基本操作</a>
              <ol>
                <li><a href="#创建数据表">创建数据表。</a>
                  <ol>
                    <li><a href="#约束">约束</a>
                      <ol>
                        <li><a href="#主键约束">主键约束</a></li>
                        <li><a href="#外键约束">外键约束</a></li>
                        <li><a href="#非空约束">非空约束</a></li>
                        <li><a href="#唯一约束">唯一约束</a></li>
                        <li><a href="#默认约束">默认约束</a></li>
                        <li><a href="#自增约束">自增约束</a></li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li><a href="#查看数据表结构">查看数据表结构</a></li>
                <li><a href="#修改表">修改表</a></li>
                <li><a href="#删除表">删除表</a></li>
              </ol>
            </li>
            <li><a href="#数据库函数">数据库函数</a>
              <ol>
                <li><a href="#数学函数">数学函数</a></li>
                <li><a href="#字符串函数">字符串函数</a></li>
                <li><a href="#日期时间函数">日期时间函数</a></li>
                <li><a href="#加密函数">加密函数</a></li>
                <li><a href="#聚合函数">聚合函数</a></li>
                <li><a href="#其他函数">其他函数</a></li>
              </ol>
            </li>
            <li><a href="#增删改表中的数据">增、删，改表中的数据</a></li>
            <li><a href="#单表的查询">单表的查询</a>
              <ol>
                <li><a href="#where">where</a></li>
                <li><a href="#分组">分组</a></li>
                <li><a href="#多字段分组">多字段分组</a></li>
                <li><a href="#having过滤分组">having过滤分组</a></li>
                <li><a href="#排序">排序</a></li>
                <li><a href="#limit">limit</a></li>
              </ol>
            </li>
            <li><a href="#连接查询">连接查询</a>
              <ol>
                <li><a href="#交叉连接">交叉连接</a></li>
                <li><a href="#内连接">内连接</a></li>
                <li><a href="#左外连接">左外连接</a></li>
                <li><a href="#右连接">右连接</a></li>
                <li><a href="#联合查询">联合查询</a></li>
              </ol>
            </li>
            <li><a href="#子查询">子查询</a></li>
            <li><a href="#起别名">起别名</a></li>
            <li><a href="#利用正则查询">利用正则查询</a></li>
            <li><a href="#索引">索引</a>
              <ol>
                <li><a href="#索引分类">索引分类</a>
                  <ol>
                    <li><a href="#普通索引和唯一索引">普通索引和唯一索引</a></li>
                    <li><a href="#单列索引和组合索引">单列索引和组合索引</a></li>
                    <li><a href="#全文索引">全文索引</a></li>
                  </ol>
                </li>
                <li><a href="#创建索引">创建索引</a>
                  <ol>
                    <li><a href="#创建表时建索引">创建表时建索引</a></li>
                    <li><a href="#修改表时增索引">修改表时增索引</a></li>
                    <li><a href="#直接increate-index">直接increate index</a></li>
                  </ol>
                </li>
                <li><a href="#删除索引">删除索引</a></li>
                <li><a href="#索引涉及原则">索引涉及原则</a></li>
                <li><a href="#索引无用的情况">索引无用的情况</a></li>
              </ol>
            </li>
            <li><a href="#视图">视图</a></li>
            <li><a href="#存储过程和函数">存储过程和函数</a>
              <ol>
                <li><a href="#创建存储过程">创建存储过程</a></li>
                <li><a href="#创建函数">创建函数</a></li>
                <li><a href="#变量及流程控制">变量及流程控制</a></li>
                <li><a href="#调用存储过程或函数">调用存储过程或函数</a></li>
                <li><a href="#查看存储过程和函数">查看存储过程和函数</a></li>
                <li><a href="#修改删除存储过程和函数">修改、删除存储过程和函数</a></li>
              </ol>
            </li>
            <li><a href="#触发器">触发器</a>
              <ol>
                <li><a href="#创建触发器">创建触发器</a>
                  <ol>
                    <li><a href="#查看删除触发器">查看、删除触发器</a></li>
                  </ol>
                </li>
              </ol>
            </li>
            <li><a href="#事务">事务</a>
              <ol>
                <li><a href="#设置事务级别">设置事务级别</a></li>
                <li><a href="#各种读问题">各种读问题</a></li>
                <li><a href="#事务使用">事务使用</a></li>
              </ol>
            </li>
            <li><a href="#三大范式">三大范式</a></li>
            <li><a href="#案例">案例</a>
              <ol>
                <li><a href="#先分组取分组内的n条">先分组取分组内的n条</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h3 id="概述">概述</h3>
<p>sql包含4个部分：</p>
<ul>
<li>数据定义语言DDL:create,drop,alter</li>
<li>数据操作语言DML:insert,update,delete</li>
<li>数据查询语言DQL:select</li>
<li>数据控制语言DCL:grant,revoke,commit,rollback</li>
</ul>
<h3 id="数据引擎">数据引擎</h3>
<p>mysql有InnoDB,MyISAM,Merge等存储引擎，我们可以针对每一个表指定引擎。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">parent</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">INNODB</span><span class="p">;</span>
</code></pre></div><p>查看支持的引擎。show engines</p>
<p>InnoDB和MyISAM对比：</p>
<ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
</ol>
<p>如何选择：</p>
<ol>
<li>是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic1.png"
        data-srcset="./pic1.png, ./pic1.png 1.5x, ./pic1.png 2x"
        data-sizes="auto"
        alt="./pic1.png"
        title="./pic1.png" /></p>
<h3 id="字符集">字符集</h3>
<p>字符集可以针对全局、数据库、表、列进行设置</p>
<ul>
<li>show variables like &lsquo;character%'; 查看当前字符集设置</li>
<li>/etc/mysql/mysql.conf.d/mysqld.cnf 文件[musqld]下增加：character-set-server =utf8</li>
<li>重启服务 sudo service mysql restart</li>
</ul>
<h3 id="数据类型">数据类型</h3>
<p>mysql数据类型主要包含整数、浮点数、日期、时间及字符串。</p>
<h4 id="整数">整数</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic2.png"
        data-srcset="./pic2.png, ./pic2.png 1.5x, ./pic2.png 2x"
        data-sizes="auto"
        alt="./pic2.png"
        title="Alt text" /></p>
<h4 id="小数">小数</h4>
<p>字段名 float(M,N)，M代表总共位数；N代表小数位数。若不知道M，N则有硬件和操作系统决定。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic3.png"
        data-srcset="./pic3.png, ./pic3.png 1.5x, ./pic3.png 2x"
        data-sizes="auto"
        alt="./pic3.png"
        title="Alt text" /></p>
<h4 id="日期时间">日期时间</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic4.png"
        data-srcset="./pic4.png, ./pic4.png 1.5x, ./pic4.png 2x"
        data-sizes="auto"
        alt="./pic4.png"
        title="Alt text" />
datetime输入什么时间取出就是什么时间，但是timestamp就是会根据数据库的时区变化。</p>
<p>我们还可以利用timestamp来指定字段插入或更新的时候自动生成/修改值</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">alter</span> <span class="k">table</span> <span class="k">user</span> <span class="k">add</span> <span class="n">last_time</span> <span class="k">timestamp</span> <span class="k">default</span> <span class="k">current_timestamp</span> <span class="k">on</span> <span class="k">update</span> <span class="k">current_timestamp</span><span class="p">;</span>
</code></pre></div><h4 id="字符串">字符串</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic5.png"
        data-srcset="./pic5.png, ./pic5.png 1.5x, ./pic5.png 2x"
        data-sizes="auto"
        alt="./pic5.png"
        title="Alt text" /></p>
<p><strong>CHAR(M), VARCHAR(M)不同之处</strong></p>
<p>CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检 索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，CHAR字段上的索引效率比较高。</p>
<p>VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间(旧版本255），(VARCHAR的最大有效长度由最大行大小和使用 的字符集确定。整体最大长度是65,532字节）。VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则 使用两个字节)。VARCHAR值保存时不进行填充。</p>
<p>enum只能选用其中的一个，而set可以是其中几个的联合，set会把值的末尾空格去除。</p>
<h4 id="二进制">二进制</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic6.png"
        data-srcset="./pic6.png, ./pic6.png 1.5x, ./pic6.png 2x"
        data-sizes="auto"
        alt="./pic6.png"
        title="Alt text" /></p>
<h4 id="数据类型的选择">数据类型的选择</h4>
<ul>
<li>在长度一定的情况下，浮点数float能表示更大的范围，但是定点数decimal更准确</li>
<li>char固定长度，自动删除尾部空格，varchar是可变长度，不会删除尾部空格。</li>
</ul>
<h3 id="数据库基本操作">数据库基本操作</h3>
<p>showdatabases查看所有数据库,其中MySQL是必须的，描述用户访问权限</p>
<ul>
<li>创建数据库。create database db1;</li>
<li>查看数据库创建信息。show create database db1;</li>
<li>删除数据库。drop database db1;</li>
<li>切换数据库。use db1;</li>
</ul>
<h3 id="数据表的基本操作">数据表的基本操作</h3>
<h4 id="创建数据表">创建数据表。</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="n">tb_name</span>
<span class="p">(</span>
	<span class="err">字段名</span><span class="mi">1</span><span class="err">，数据类型</span><span class="p">[</span><span class="err">列级别约束条件</span><span class="p">][</span><span class="err">默认值</span><span class="p">]</span><span class="err">，</span>
	<span class="err">字段名</span><span class="mi">2</span><span class="err">，数据类型</span><span class="p">[</span><span class="err">列级别约束条件</span><span class="p">][</span><span class="err">默认值</span><span class="p">]</span>
<span class="p">)</span>
</code></pre></div><h5 id="约束">约束</h5>
<h6 id="主键约束">主键约束</h6>
<ol>
<li>主键约束。要求唯一，不能为空。
可以直接在类型后指定，也可以定义完所有的列之后指定。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="n">tb1</span>
<span class="p">(</span>
	<span class="n">id</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">create</span> <span class="k">table</span> <span class="n">tb2</span>
<span class="p">(</span>
	<span class="n">id</span> <span class="nb">int</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
	<span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div><ol start="2">
<li>联合主键约束。
联合主键要用第二种声明方式了。</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="n">tb2</span>
<span class="p">(</span>
	<span class="n">id</span> <span class="nb">int</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
	<span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">name</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div><h6 id="外键约束">外键约束</h6>
<p>只有InnoDB引擎才能使用外键
外键约束用在表之间建立链接。可以是一列或多列。外键可以为空值，如果不为空则必须等于另一个表中的主键。</p>
<p>外键不一定必须是另一个表的主键，只要满足唯一性就好。</p>
<p>外键中主键所在的那个表是主表，想关联外表的表是从表。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="k">if</span> <span class="k">not</span> <span class="k">exists</span> <span class="k">user</span>
<span class="p">(</span>
	<span class="n">id</span> <span class="nb">int</span><span class="p">,</span>
	<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span>
	<span class="n">classid</span> <span class="nb">int</span><span class="p">,</span>
	<span class="n">cityid</span> <span class="nb">int</span><span class="p">,</span>
	<span class="k">constraint</span> <span class="n">fk_user_class</span> <span class="k">foreign</span> <span class="k">key</span> <span class="p">(</span><span class="n">classid</span><span class="p">)</span> <span class="k">references</span> <span class="k">class</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">on</span> <span class="k">delete</span> <span class="k">cascade</span> <span class="k">on</span> <span class="k">update</span> <span class="k">cascade</span><span class="p">,</span>
	<span class="k">constraint</span> <span class="n">fk_user_city</span> <span class="k">foreign</span> <span class="k">key</span> <span class="p">(</span><span class="n">cityid</span><span class="p">)</span> <span class="k">references</span> <span class="n">city</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div><p>user表classid，cityid分别链接class，city表中的id。</p>
<p>另外我们还自定义了一个on，当我们没指定on的时候，删除和修改主表中的主键都是不可以的。
<strong>on delete，on update</strong>后面都可以跟参数，有4种参数：</p>
<ol>
<li>restrict方式：严格模式，同no action，都是立即检查外键约束；不能删除和改</li>
<li>cascade方式：也叫级联方式，在父表上update/delete记录时，同步update/delete子表的匹配记录</li>
<li>No action方式：如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete</li>
<li>set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null 要注意子表的外键列不能为not null</li>
</ol>
<p>外键默认是严格模式。</p>
<h6 id="非空约束">非空约束</h6>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="k">class</span>
<span class="p">(</span>
<span class="n">id</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span>
<span class="p">)</span>
</code></pre></div><h6 id="唯一约束">唯一约束</h6>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="n">person</span>
<span class="p">(</span>
<span class="n">id</span> <span class="nb">int</span> <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
<span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">unique</span>
<span class="p">)</span>
</code></pre></div><p>要求表中该值唯一，但只能出现一个空值。但是mysql是可以多个null的。</p>
<h6 id="默认约束">默认约束</h6>
<p>字段名 数据类型 default 默认值
比如用户表男性较多，那么性别默认值可以设置为男</p>
<h6 id="自增约束">自增约束</h6>
<p>自增类型可以是任何整数类型
字段名 数据类型 auto_increment</p>
<h4 id="查看数据表结构">查看数据表结构</h4>
<ul>
<li>desc tb1 查看表的结构</li>
<li>show create table tb1 查看表的创建语句</li>
</ul>
<h4 id="修改表">修改表</h4>
<ul>
<li>重命名表 alter table 旧表名 rename 新表名</li>
<li>修改表引擎 alter table 表名 engine=&quot;InnoDB&rdquo;</li>
<li>修改字段类型 alter table 表名  change 旧字段  新字段 数据类型</li>
<li>添加字段 alter table 表名 add 字段名 类型（这里我们可以指定字段的位置）</li>
<li>删除字段 alter table 表名 drop 字段名</li>
<li>添加外键 alter table  表名 add constraint 外键名 foreign key （字段名）references 主表名（字段名）</li>
<li>删除外键 alter table 表名 drop foreign key 外键名</li>
</ul>
<h4 id="删除表">删除表</h4>
<ul>
<li>删除表 drop table 表名1，表名2&hellip;
如果有字段被其他表关联，要先删除外键</li>
</ul>
<h3 id="数据库函数">数据库函数</h3>
<h4 id="数学函数">数学函数</h4>
<p>常见的有:</p>
<ul>
<li>绝对值函数abs(x)</li>
<li>三角函数</li>
<li>随机函数 rand(),rand(x)  0&lt;=结果&lt;=1，x是种子</li>
<li>向上取整 ceil(x)</li>
<li>向下取整 floor(x)</li>
<li>平均值 avg(x)</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="k">avg</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">from</span> <span class="k">user</span><span class="p">;</span>
</code></pre></div><h4 id="字符串函数">字符串函数</h4>
<ul>
<li>长度 char_length(&ldquo;xxx&rdquo;)</li>
<li>小写 lcase(&ldquo;XXX&rdquo;)</li>
<li>大写 ucase(&ldquo;xxx&rdquo;)</li>
<li>去除空格 trim(”x&rdquo;)，ltrim(&ldquo;xx&rdquo;)，rtrim(&ldquo;xx&rdquo;)</li>
<li>取子串 substring(&ldquo;str&rdquo;,start,len) start从1开始，负数表示从后面开始</li>
<li>子串位置 instr(“abcd”,&ldquo;c&rdquo;)</li>
<li>字符串翻转 reverse(&ldquo;abc&rdquo;)</li>
</ul>
<h4 id="日期时间函数">日期时间函数</h4>
<ul>
<li>当前时间 now()</li>
<li>当前日期 current_date()</li>
<li>当前时间 current_time()</li>
<li>获取年月日year(now())，month(now())，day(now())</li>
<li>格式化 date_format(date,format)</li>
<li>日期时间加减 date_add()，addtime()等</li>
</ul>
<h4 id="加密函数">加密函数</h4>
<ul>
<li>md加密 md5(str)</li>
</ul>
<h4 id="聚合函数">聚合函数</h4>
<ul>
<li>AVG()函数忽略列值为NULL的行。</li>
<li>MAX()函数忽略列值为NULL的行。</li>
<li>MIN()函数忽略列值为NULL的行。</li>
<li>SUM()函数忽略列值为NULL的行。</li>
<li>COUNT()函数有两种使用方式：
使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。
使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
<h4 id="其他函数">其他函数</h4>
<ul>
<li>返回最近一次插入的数据的id last_insert_id()
这里需要注意，last_insert_id是与表无关的，向a插入，再向b插入，获取的是b表的最新id</li>
</ul>
<h3 id="增删改表中的数据">增、删，改表中的数据</h3>
<ul>
<li>插入数据 insert into 表名（字段名，字段名）values(值，值)；</li>
<li>将查询结果插入数据表 insert  into 表名 （字段名）select &hellip;.</li>
<li>修改数据 update 表名 set 字段名=value，字段名=value [条件]</li>
<li>删除数据 delete from 表名 [条件]</li>
</ul>
<h3 id="单表的查询">单表的查询</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span>
	<span class="err">{</span><span class="o">*</span> <span class="o">|</span><span class="err">字段列表}</span>
	<span class="p">[</span>
		<span class="k">from</span> <span class="err">表</span><span class="mi">1</span><span class="err">，表</span><span class="mi">2</span>
		<span class="p">[</span><span class="k">where</span><span class="p">]</span>
		<span class="p">[</span><span class="k">group</span> <span class="k">by</span><span class="p">]</span>
		<span class="p">[</span><span class="k">having</span><span class="p">]</span>
		<span class="p">[</span><span class="k">order</span> <span class="k">by</span><span class="p">]</span>
		<span class="p">[</span><span class="k">limit</span> <span class="p">[</span><span class="n">offet</span><span class="p">,]</span><span class="n">rowcount</span><span class="p">]</span>
	<span class="p">]</span>
</code></pre></div><h4 id="where">where</h4>
<ul>
<li>in操作 where id in (1,2,3)或者where id not in(1,2,3)</li>
<li>位于两者之间 where price between 1 and 2或者where price not between 1 and 2</li>
<li>通配符 where name like &lsquo;%xxx%'。_只能通配一个字符</li>
<li>is null判断 where name is null或者where name not is null</li>
<li>多个条件 用and连接</li>
<li>条件或用or连接</li>
<li>去重 select distinct 字段名</li>
</ul>
<h4 id="分组">分组</h4>
<p>分组通常和count(),max()等函数配合使用
比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="n">s_id</span><span class="p">,</span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">fruits</span> <span class="k">group</span> <span class="k">by</span> <span class="n">s_id</span>
</code></pre></div><p>另外group_concat(字段名)可以把分组中想要的各字段名显示出来</p>
<h4 id="多字段分组">多字段分组</h4>
<p>分组可以指定多个字段，先按第一个字段分组，再按第二个分组，一次类推。</p>
<h4 id="having过滤分组">having过滤分组</h4>
<p>group by 和having配合，只有满足条件的分组才能被显示。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="n">s_id</span><span class="p">,</span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">fruits</span> <span class="k">group</span> <span class="k">by</span> <span class="n">s_id</span> <span class="k">having</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span>
</code></pre></div><h4 id="排序">排序</h4>
<ul>
<li>order by 字段名，字段名 [asc/desc] 默认升序</li>
<li>如果有分组是对分组的排序</li>
</ul>
<h4 id="limit">limit</h4>
<ul>
<li>limit[offset] rows</li>
<li>如果想跳过n行取所有，可以指定一个很大的数字</li>
</ul>
<h3 id="连接查询">连接查询</h3>
<p>连接查询就是对2个或2个以上的表连接为一个表进行查询。</p>
<ul>
<li>from 表1 [链接方式] join 表2 [on 条件]</li>
</ul>
<p>链接方式常有交叉链接cross,内连接inner，左外连接left,右外连接right</p>
<h4 id="交叉连接">交叉连接</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">cross</span> <span class="k">join</span> <span class="k">class</span><span class="p">;</span>
</code></pre></div><p>这样的话，左表每条记录分别和右表每条记录连接，造成很大的无用的数据，实际意义不大。</p>
<h4 id="内连接">内连接</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">inner</span> <span class="k">join</span> <span class="k">class</span> <span class="k">on</span> <span class="k">user</span><span class="p">.</span><span class="n">classid</span><span class="o">=</span><span class="k">class</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div><p>保留的都是满足条件的记录，使用最多。
除此之外，内连接还有where形式的：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span><span class="p">,</span><span class="k">class</span> <span class="k">where</span> <span class="k">user</span><span class="p">.</span><span class="n">classid</span><span class="o">=</span><span class="k">class</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div><p><strong>但是where相比inner join on效率低</strong></p>
<h4 id="左外连接">左外连接</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">left</span> <span class="k">join</span> <span class="k">class</span> <span class="k">on</span> <span class="k">user</span><span class="p">.</span><span class="n">classid</span><span class="o">=</span><span class="k">class</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div><p>在进行连接后，以左边的表为主，左边表所有的数据都会显示在结果中，哪怕他们不符合on后边的条件，此时右边表的数据显示null
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic8.png"
        data-srcset="./pic8.png, ./pic8.png 1.5x, ./pic8.png 2x"
        data-sizes="auto"
        alt="./pic8.png"
        title="Alt text" /></p>
<h4 id="右连接">右连接</h4>
<p>右连接和左连接类似，只不过是以右边为主</p>
<h4 id="联合查询">联合查询</h4>
<p>联合查询就是把多个查询语句结果集中在一起。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="k">column_name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">table_name1</span>
<span class="k">UNION</span>
<span class="k">SELECT</span> <span class="k">column_name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">table_name2</span>
</code></pre></div><p>联合的时候两个结果集的字段名不要求一样，但是数量和类型要求一样。</p>
<ul>
<li>union联合的时候不包括重复行</li>
<li>union all联合的时候包括重复行</li>
</ul>
<h3 id="子查询">子查询</h3>
<p>子查询是指一个查询语句嵌套在另一个查询语句中，首先内部子查询的结果作为外部查询的输入。</p>
<ul>
<li>any 只要满足子查询随意的一个结果即可</li>
<li>all 满足所有子查询的结果</li>
<li>exists 子查询如果查到了一行，那么exists就是true,否则为false外查询不进行查询</li>
<li>in 存在和子查询中的结果一样的数据</li>
<li>not in 参考in</li>
</ul>
<h3 id="起别名">起别名</h3>
<ul>
<li>字段 [as] 别名</li>
<li>表 [as] 别名</li>
</ul>
<h3 id="利用正则查询">利用正则查询</h3>
<p>利用正则匹配查询</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">name</span> <span class="n">regexp</span> <span class="s2">&#34;^h&#34;</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">name</span> <span class="n">regexp</span> <span class="s2">&#34;a$&#34;</span>
</code></pre></div><p>查询name以h开头的数据，name以a结尾的数据。</p>
<h3 id="索引">索引</h3>
<p>索引是一个独立的、存在在磁盘上的数据库结构，它包含着表里所有记录的引用指针。有了索引查询的时候就不用从头到尾一行一行的判断了，速度更快。比如两万条数据，select * from user where id =30必须遍历表。有了索引直接找到id=30的行。</p>
<ul>
<li>mysql的索引类型有btree和hash，具体和存储引擎相关。</li>
</ul>
<p>索引优点：</p>
<ul>
<li>通过创建唯一索引，保证每一条数据的唯一性</li>
<li>大大提升查询速度，这是主要原因</li>
</ul>
<p>索引缺点</p>
<ul>
<li>创建和维护需要时间，尤其是数据量大以后，每次插入要排序</li>
<li>占用空间</li>
</ul>
<h4 id="索引分类">索引分类</h4>
<h5 id="普通索引和唯一索引">普通索引和唯一索引</h5>
<p>普通索引允许索引列有重复值和空值。</p>
<p>唯一索引必须唯一，可以为空。主键索引是特殊的唯一索引，不能为空。
<strong>mysql创建外键的时候会自动为该列创建普通索引</strong></p>
<h5 id="单列索引和组合索引">单列索引和组合索引</h5>
<p>单列索引顾名思义就是只包含一个列。</p>
<p>组合索引包含多个列，联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。</p>
<h5 id="全文索引">全文索引</h5>
<p>全文索引可以在char、varchar或者text类型上创建。
常用的全文检索模式有两种：</p>
<ol>
<li>自然语言的全文索引
自然语言模式是MySQL 默认的全文检索模式。自然语言模式不能使用操作符，不能指定关键词必须出现或者必须不能出现等复杂查询。
默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行自然语言搜索，上面的例子都是自然语言的全文索引。</li>
</ol>
<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。上面提到的，测试表中必须有 4 条以上的记录，就是这个原因。</p>
<p>这个机制也比较好理解，比如说，一个数据表存储的是一篇篇的文章，文章中的常见词、语气词等等，出现的肯定比较多，搜索这些词语就没什么意义了，需要搜索的是那些文章中有特殊意义的词，这样才能把文章区分开。</p>
<ol start="2">
<li>布尔全文索引
在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。</li>
</ol>
<p>MySQL 内置的修饰符，上面查询最小搜索长度时，搜索结果 ft_boolean_syntax 变量的值就是内置的修饰符，下面简单解释几个，更多修饰符的作用可以查手册</p>
<ul>
<li>必须包含该词</li>
</ul>
<ul>
<li>必须不包含该词</li>
</ul>
<blockquote>
<p>提高该词的相关性，查询的结果靠前
&lt; 降低该词的相关性，查询的结果靠后
(*)星号 通配符，只能接在词后面
对于上面提到的问题，可以使用布尔全文索引查询来解决，使用下面的命令，a、aa、aaa、aaaa 就都被查询出来了。</p>
</blockquote>
<p>select * test where match(content) against(&lsquo;a*&rsquo; in boolean mode);</p>
<blockquote>
<p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。
最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引。</p>
</blockquote>
<h4 id="创建索引">创建索引</h4>
<p>创建表的时候，修改表的时候或者直接create index都可以创建索引。
<strong>一个列上可以创建多个索引</strong></p>
<h5 id="创建表时建索引">创建表时建索引</h5>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">table</span> <span class="err">表名</span> <span class="p">[</span><span class="err">字段名</span> <span class="err">类型</span><span class="p">]</span> <span class="p">[</span><span class="n">unionque</span><span class="o">|</span><span class="n">fulltext</span><span class="o">|</span><span class="n">spatial</span><span class="p">]</span> <span class="p">[</span><span class="k">index</span><span class="o">|</span><span class="k">key</span><span class="p">]</span> <span class="p">[</span><span class="err">索引名</span><span class="p">]</span> <span class="p">(</span><span class="err">字段名</span><span class="p">[</span><span class="k">length</span><span class="p">])</span> <span class="p">[</span><span class="k">asc</span><span class="o">|</span><span class="k">desc</span><span class="p">]</span>
</code></pre></div><p>其中unique、fulltext、spatial分别代表唯一、全文、空间索引，不指定时为普通索引；index和key意义一样；索引名可以为空，此时索引名默认为列名；asc或desc代表升序或降序的索引。</p>
<p>**explain select * from user where id=30;**利用explain可以查看执行的时候是不是用到了索引。</p>
<h5 id="修改表时增索引">修改表时增索引</h5>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">alter</span> <span class="k">table</span> <span class="err">表名</span> <span class="k">add</span> <span class="p">[</span><span class="n">unionque</span><span class="o">|</span><span class="n">fulltext</span><span class="o">|</span><span class="n">spatial</span><span class="p">]</span> <span class="p">[</span><span class="k">index</span><span class="o">|</span><span class="k">key</span><span class="p">]</span> <span class="p">[</span><span class="err">索引名</span><span class="p">]</span> <span class="p">(</span><span class="err">字段名</span><span class="p">[</span><span class="k">length</span><span class="p">])</span> <span class="p">[</span><span class="k">asc</span><span class="o">|</span><span class="k">desc</span><span class="p">]</span>
</code></pre></div><h5 id="直接increate-index">直接increate index</h5>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="p">[</span><span class="n">unionque</span><span class="o">|</span><span class="n">fulltext</span><span class="o">|</span><span class="n">spatial</span><span class="p">]</span> <span class="p">[</span><span class="k">index</span><span class="o">|</span><span class="k">key</span><span class="p">]</span>  <span class="p">[</span><span class="err">索引名</span><span class="p">]</span> <span class="k">on</span> <span class="err">表名</span> <span class="p">(</span><span class="err">字段名</span><span class="p">[</span><span class="k">length</span><span class="p">])</span> <span class="p">[</span><span class="k">asc</span><span class="o">|</span><span class="k">desc</span><span class="p">]</span>
</code></pre></div><h4 id="删除索引">删除索引</h4>
<ul>
<li>drop index 索引名 on 表名</li>
<li>alter table  表名 drop index 索引名</li>
</ul>
<h4 id="索引涉及原则">索引涉及原则</h4>
<ul>
<li>索引并不是越多越好</li>
<li>避免经常更新的表进行索引，并且索引尽可能少。经常查询的表可以建索引。</li>
<li>数据量少的话不用建索引，不然适得其反。</li>
<li>如果列上相同的值很多，不适合建索引，比如性别列</li>
<li>频繁进行排序order by和分组group by的列上适合创建索引</li>
<li>尽量使用短索引，比如有的字段0-255，实际上前10个字符就能判断出唯一，可指定索引长度10</li>
</ul>
<h4 id="索引无用的情况">索引无用的情况</h4>
<p>利用索引可以直接定位，免去了遍历，是最有效的优化查询方案。但是有些情况虽然字段带索引，是不起作用的：</p>
<ul>
<li>利用like，而且%在第一个位置，索引无效。</li>
<li>一个索引可以有16个字段，只有查询条件是索引的第一个字段时才有效。</li>
<li>查询条件有or时，or前后条件都是索引才有效。</li>
</ul>
<h3 id="视图">视图</h3>
<p>视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。</p>
<p>通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用视图动态生成。</p>
<p>视图本身没有数据，数据的变化是修改的数据表。
<strong>不是所有的视图都可以做DML操作。</strong></p>
<p>有下列内容之一，视图不能做DML操作：</p>
<p>　　①select子句中包含distinct</p>
<p>　　②select子句中包含组函数</p>
<p>　　③select语句中包含group by子句</p>
<p>　　④select语句中包含order by子句</p>
<p>　　⑤select语句中包含union 、union all等集合运算符</p>
<p>　　⑥where子句中包含相关子查询</p>
<p>　　⑦from子句中包含多个表</p>
<p>　　⑧如果视图中有计算列，则不能更新</p>
<p>　　⑨如果基表中有某个具有非空约束的列未出现在视图定义中，则不能做insert操作</p>
<h3 id="存储过程和函数">存储过程和函数</h3>
<p>存储过程可以简单的看成一条或多条sql语句的集合。</p>
<h4 id="创建存储过程">创建存储过程</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">procedure</span> <span class="n">sp_name</span> <span class="p">([</span><span class="n">param</span><span class="p">])</span>
<span class="p">[</span><span class="k">characteristics</span> <span class="p">...]</span> <span class="n">routine_body</span>
</code></pre></div><p>其中参数可以是 IN OUT INOUT三种类型
routine_body是sql代码的内容，可以用begin&hellip;end开始和结束。
示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">delimiter</span> <span class="o">//</span>
<span class="k">create</span> <span class="k">procedure</span> <span class="n">pdtest</span><span class="p">()</span>
<span class="k">begin</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="k">user</span><span class="p">;</span>
<span class="k">end</span> <span class="o">//</span>
</code></pre></div><p>delimiter //指定语句用//来结束，防止与sql语句冲突，定义完存储过程后，在回到原来的delimiter ;</p>
<h4 id="创建函数">创建函数</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">function</span> <span class="n">func_name</span><span class="p">([</span><span class="n">param</span><span class="p">])</span>
<span class="k">returns</span> <span class="k">type</span>
<span class="p">[</span><span class="n">characteristic</span><span class="p">...]</span> <span class="n">routine_body</span>
</code></pre></div><p>参数和存储过程一样，也是那三种，默认是IN。
returns types是必须要的。不需要begin end
示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">delimiter</span> <span class="o">//</span>
<span class="k">create</span> <span class="k">function</span> <span class="n">functest</span><span class="p">()</span>
<span class="k">returns</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">return</span> <span class="p">(</span><span class="k">select</span> <span class="n">name</span> <span class="k">from</span> <span class="k">user</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>
<span class="o">//</span>
</code></pre></div><h4 id="变量及流程控制">变量及流程控制</h4>
<p>我们可以声明变量、使用流程控制、光标等。</p>
<h4 id="调用存储过程或函数">调用存储过程或函数</h4>
<ul>
<li>call pd_name() 调用存储过程</li>
<li>select func_name() 调用函数</li>
</ul>
<h4 id="查看存储过程和函数">查看存储过程和函数</h4>
<ul>
<li>show {procedure | function} status [like &ldquo;pattern&rdquo;]</li>
<li>show create {procedure | function} name</li>
</ul>
<h4 id="修改删除存储过程和函数">修改、删除存储过程和函数</h4>
<ul>
<li>alter {procedure | function}  name&hellip;</li>
<li>drop procedure name;</li>
<li>drop function name;</li>
</ul>
<h3 id="触发器">触发器</h3>
<p>触发器和存储过程类似，都是嵌入到mysql的一段程序。
触发器是由事件触发某个操作，包括insert、update、delete。</p>
<h4 id="创建触发器">创建触发器</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">trigger</span> <span class="k">trigger_name</span> <span class="n">trigger_time</span> <span class="n">trigger_event</span> <span class="k">on</span> <span class="n">ta_name</span> <span class="k">for</span> <span class="k">each</span> <span class="k">row</span> <span class="n">trigger_stmt</span>
</code></pre></div><p>当有多条sql语句时，用begin end</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">trigger</span> <span class="k">trigger_name</span> <span class="n">trigger_time</span> <span class="n">trigger_event</span> <span class="k">on</span> <span class="n">ta_name</span> <span class="k">for</span> <span class="k">each</span> <span class="k">row</span> 
<span class="k">begin</span>
<span class="n">trigger_stmt</span><span class="p">...</span>
<span class="k">end</span>
</code></pre></div><p>示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span> <span class="k">trigger</span> <span class="n">tgtest</span> <span class="k">after</span> <span class="k">update</span> <span class="k">on</span> <span class="k">user</span> <span class="k">for</span> <span class="k">each</span> <span class="k">row</span> 
<span class="k">begin</span>
<span class="p">...</span><span class="o">//</span><span class="err">此处小心插入死循环</span>
<span class="k">end</span>
</code></pre></div><h5 id="查看删除触发器">查看、删除触发器</h5>
<ul>
<li>show triggers;</li>
<li>直接从information_schema数据库triggers表中查，另外还有存储过程和函数表</li>
<li>drop trigger name</li>
</ul>
<h3 id="事务">事务</h3>
<p>MyISAM 不支持事务，InnoDB支持事务。</p>
<p>在innodb里面， 所有的活动都是运行在事务里面的。innodb默认autocommit=1的，意思就是MySQL会在每个语句执行的时候自动提交事务，当然是语句没有报错，如果报错了，那就会自动回滚rollback。</p>
<ul>
<li>查看当前autocommit模式</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;autocommit&#39;</span><span class="p">;</span>
</code></pre></div><h4 id="设置事务级别">设置事务级别</h4>
<ul>
<li>开启autocommit模式</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span> <span class="p">[</span><span class="k">SESSION</span> <span class="o">|</span> <span class="k">GLOBAL</span><span class="p">]</span> <span class="k">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span> <span class="err">{</span><span class="k">READ</span> <span class="k">UNCOMMITTED</span> <span class="o">|</span> <span class="k">READ</span> <span class="k">COMMITTED</span> <span class="o">|</span> <span class="k">REPEATABLE</span> <span class="k">READ</span> <span class="o">|</span> <span class="k">SERIALIZABLE</span><span class="err">}</span>
</code></pre></div><p>这里session是指对当前连接上执行的事务设置默认事务级别。默认是对下一个（未开始）事务设置隔离级别</p>
<ul>
<li>查看事务隔离级别</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="o">@@</span><span class="k">global</span><span class="p">.</span><span class="n">tx_isolation</span><span class="p">;</span> 
<span class="k">SELECT</span> <span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">tx_isolation</span><span class="p">;</span> 
<span class="k">SELECT</span> <span class="o">@@</span><span class="n">tx_isolation</span><span class="p">;</span>
</code></pre></div><h4 id="各种读问题">各种读问题</h4>
<ul>
<li>未提交读（Read uncommitted）就是能读取到其他回话中未提交事务的修改，造成脏读问题。
<ul>
<li>脏读。就是一个事务读取到了另一个事务修改还未提交的数据变化，因为这个变化可能被恢复。</li>
</ul>
</li>
<li>提交读(Read Committed) 只能读取到别人已经提提交的数据。避免了脏读的问题。但是在自己的事务中多次读取，数据可能不一致也就是不可重复读。
<ul>
<li>不可重复读。就是在同一事务中多次读一个数据，但是不一致，因为期间哟其他事务修改并提交了。</li>
</ul>
</li>
<li>可重复读(Repeated Read) <strong>InnoDB默认级别</strong>，同一个事务中多次读取都是一致的，解决了不可重复读的问题。但是有幻读问题。
<ul>
<li>幻读。可重复读级别虽然外部的修改和插入不会影响本事务查看数据，但是可能影响本事务修改或插入。</li>
</ul>
</li>
<li>串行读(Serializable)  现在好了，完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。</li>
</ul>
<h4 id="事务使用">事务使用</h4>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">start</span> <span class="k">transaction</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="k">commit</span><span class="p">;</span><span class="o">//</span><span class="k">rollback</span><span class="p">;</span>
</code></pre></div><h3 id="三大范式">三大范式</h3>
<ul>
<li>第一范式:确保每列的原子性.
第一范式是最基本的范式。</li>
</ul>
<p>数据库表中的字段都是单一属性的，不可再分。</p>
<p>只要是关系数据库都满足第一范式</p>
<p>如果每列(或者每个属性)都是不可再分的最小数据单元(也称为最小的原子单元),则满足第一范式.</p>
<p>例如:顾客表(姓名、编号、地址、……)其中&quot;地址&quot;列还可以细分为国家、省、市、区等。</p>
<ul>
<li>第二范式(确保表中的每列都和主键相关).
如果一个关系满足第一范式,并且除了主键以外的其它列,都依赖于该主键,则满足第二范式.</li>
</ul>
<p>例如:订单表(订单编号、产品编号、定购日期、价格、……)，&ldquo;订单编号&quot;为主键，&ldquo;产品编号&quot;和主键列没有直接的关系，即&quot;产品编号&quot;列不依赖于主键列，应删除该列。</p>
<ul>
<li>第三范式(确保每列都和主键列直接相关,而不是间接相关).</li>
</ul>
<p>如果一个关系满足第二范式,并且除了主键以外的其它列都不依赖于主键列,则满足第三范式.</p>
<p>为了理解第三范式，需要根据Armstrong公里之一定义传递依赖。假设A、B和C是关系R的三个属性，如果A-〉B且B-〉C，则从这些函数依赖中，可以得出A-〉C，如上所述，依赖A-〉C是传递依赖。</p>
<p>例如:订单表(订单编号，定购日期，顾客编号，顾客姓名，……)，初看该表没有问题，满足第二范式，每列都和主键列&quot;订单编号&quot;相关，再细看你会发现&quot;顾客姓名&quot;和&quot;顾客编号&quot;相关，&ldquo;顾客编号&quot;和&quot;订单编号&quot;又相关，最后经过传递依赖，&ldquo;顾客姓名&quot;也和&quot;订单编号&quot;相关。为了满足第三范式，应去掉&quot;顾客姓名&quot;列，放入客户表中。</p>
<h3 id="案例">案例</h3>
<h4 id="先分组取分组内的n条">先分组取分组内的n条</h4>
<p>查询男、女生前两名</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span> 
<span class="k">from</span> <span class="n">student</span> <span class="n">a</span> <span class="k">where</span>
<span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="k">distinct</span> <span class="n">b</span><span class="p">.</span><span class="n">score</span><span class="p">)</span> <span class="k">from</span> <span class="n">student</span> <span class="n">b</span> <span class="k">where</span> <span class="n">a</span><span class="p">.</span><span class="n">sex</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">sex</span> <span class="k">and</span> <span class="n">b</span><span class="p">.</span><span class="n">score</span><span class="o">&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">score</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div><p>其中子查询的select取决于外面的查询，每次拿外面的一个数据带入到里面进行判断，如果比他分数大的人少于两个，那么不用说他在前两名，满足条件。</p>
<p>为啥要distinct？因为分数可能有重复！</p>
<p>看比他大的在两个以内那就是前两名，注意条件中&lt;=和&lt;的区别</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2019-03-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/mysql/">mysql</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/mysql_%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B0/" class="prev" rel="prev" title="mysql必知必会笔记"><i class="fas fa-angle-left fa-fw"></i>mysql必知必会笔记</a>
            <a href="/posts/mysql_2/" class="next" rel="next" title="mysql备份、主从">mysql备份、主从<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2019-03-01T17:55:28+08:00","owner":"xingliuhua","repo":"https://github.com/xingliuhua/xingliuhua.github.io","title":"mysql基础"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
