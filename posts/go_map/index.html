<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>go map - xingliuhua博客</title><meta name="Description" content="go map"><meta property="og:title" content="go map" />
<meta property="og:description" content="go map" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/go_map/" /><meta property="og:image" content="https://xingliuhua.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-05T17:55:28+08:00" />
<meta property="article:modified_time" content="2017-05-05T17:55:28+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="go map"/>
<meta name="twitter:description" content="go map"/>
<meta name="application-name" content="xingliuhua博客">
<meta name="apple-mobile-web-app-title" content="xingliuhua博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/go_map/" /><link rel="prev" href="https://xingliuhua.github.io/posts/go_slice/" /><link rel="next" href="https://xingliuhua.github.io/posts/go_channel/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "go map",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/go_map\/"
        },"genre": "posts","keywords": "golang","wordcount":  3944 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/go_map\/","datePublished": "2017-05-05T17:55:28+08:00","dateModified": "2017-05-05T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "go map"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">go map</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2017-05-05">2017-05-05</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3944 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 8 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li><a href="#hash冲突">hash冲突</a></li>
    <li><a href="#map内存模型">map内存模型</a></li>
    <li><a href="#使用map">使用map</a></li>
    <li><a href="#key定位过程">key定位过程</a></li>
    <li><a href="#map的初始化">map的初始化</a></li>
    <li><a href="#扩容">扩容</a>
      <ol>
        <li><a href="#2倍扩容">2倍扩容</a></li>
        <li><a href="#相同容量扩容">相同容量扩容</a></li>
        <li><a href="#扩容流程">扩容流程</a>
          <ol>
            <li><a href="#等量扩容流程">等量扩容流程</a></li>
            <li><a href="#2倍的扩容流程">2倍的扩容流程</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#put">put</a></li>
    <li><a href="#get">get</a></li>
    <li><a href="#delete">delete</a></li>
    <li><a href="#其他">其他</a></li>
    <li><a href="#总结">总结</a></li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h1 id="hash冲突">hash冲突</h1>
<p>哈希查找表一般会存在“碰撞”的问题，就是说不同的 key 被哈希到了同一个 bucket。一般有两种应对方法：链表法和开放地址法。链表法将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。开放地址法则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。</p>
<p>go使用的是链表法来解决hash冲突。</p>
<h1 id="map内存模型">map内存模型</h1>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A header for a Go map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 元素个数，调用 len(map) 时，直接返回此值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">count</span>     <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">flags</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// buckets 的对数 log_2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">B</span>         <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// overflow 的 bucket 近似数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">noverflow</span> <span class="kt">uint16</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 计算 key 的哈希的时候会传入哈希函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">hash0</span>     <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 指向 buckets 数组，大小为 2^B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果元素个数为0，就为 nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 扩容的时候，buckets 长度会是 oldbuckets 的两倍
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 指示扩容进度，小于此地址的 buckets 迁移完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nevacuate</span>  <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// optional fields
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>B就是buckets数组的长度的对数，即有2^B个桶。</p>
<p>bucket桶的运行时数据结构为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">topbits</span>  <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="nx">keys</span>     <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">keytype</span>
</span></span><span class="line"><span class="cl">    <span class="nx">values</span>   <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">valuetype</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pad</span>      <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">overflow</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic1.png"
        data-srcset="./pic1.png, ./pic1.png 1.5x, ./pic1.png 2x"
        data-sizes="auto"
        alt="./pic1.png"
        title="./pic1.png" />
我们可以看到桶里面有个数组是存放各key的hash值的高8位，key是放一起，value又是放一起。
key和value为什么要分开？
源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。
map[int64]int8
如果按照 key/value/key/value/&hellip; 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 key/key/&hellip;/value/value/&hellip;，则只需要在最后添加 padding。</p>
<h1 id="使用map">使用map</h1>
<p>使用map很简单，利用make内建函数，通过汇编语言可以看到，实际上底层调用的是 makemap 函数，主要做的工作就是初始化 hmap 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。</p>
<p><code>注意</code>，这个函数返回的结果：*hmap，它是一个指针，所以map看起来像是引用。</p>
<h1 id="key定位过程">key定位过程</h1>
<p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64位机，32位机就不讨论了，现在主流都是64位机），计算它到底要落在哪个桶时，只会用到最后 B 个 bit 位。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p>
<p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex"><span class="line"><span class="cl">10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
</span></span></code></pre></div><p>用最后的 5 个 bit 位，也就是 01010，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p>
<p>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p>
<p>当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p>
<p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p>
<p>总结：对key进行hash运算取到值，低位也是就hash的右边（具体几位看B）来确定是在哪个桶中，高位也就是hash的左边8位来确定key在桶中的位置。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic3.png"
        data-srcset="./pic3.png, ./pic3.png 1.5x, ./pic3.png 2x"
        data-sizes="auto"
        alt="./pic3.png"
        title="./pic3.png" /></p>
<h1 id="map的初始化">map的初始化</h1>
<ol>
<li>根据传入的 bucket 类型，获取其类型能够申请的最大容量大小。并对其长度 make(map[k]v, hint) 进行边界值检验</li>
<li>初始化 hmap</li>
<li>初始化哈希因子</li>
<li>根据传入的 hint，计算一个可以放下 hint 个元素的桶 B 的最小值</li>
<li>分配并初始化 hash table。如果 B 为 0 将在后续懒惰分配桶，大于 0 则会马上进行分配</li>
<li>返回初始化完毕的 hmap</li>
</ol>
<p>当hint&lt;8时，最少一个bucket就可以了，否则，至少需要两个bucket，就需要立刻分配hash table。</p>
<h1 id="扩容">扩容</h1>
<p>在向 map 插入新 key 的时候，会进行条件检测，符合条件就会触发扩容。</p>
<p>扩容的方式</p>
<ul>
<li>溢出桶太多，相同容量扩容</li>
<li>达到加载因子，2倍容量扩容</li>
</ul>
<p>除了满足两个条件之一外，还要满足“不在扩容中”。</p>
<p>if (不是正在扩容 &amp;&amp; (元素个数/bucket数超过某个值 || 太多overflow bucket)) {
进行扩容
}</p>
<p>啥意思呢？第一种出现的情况是：因为map不断的put和delete，出现了很多空格，这些空格会导致bmap很长，但是中间有很多空的地方，扫描时间变长。所以第一种扩容实际是一种整理，将数据整理到前面一起。第二种呢：就是真的不够用了，扩容两倍。</p>
<h2 id="2倍扩容">2倍扩容</h2>
<p>理想中每个bucket里面只放一个元素，这样最快，但是空间太大。go采用链表解决冲突，但是，如果所有的key都在一个bucket里面，那就退化成了链表，因此需要衡量。</p>
<p><code>装载因子</code>就是衡量标准，
loadFactor := count / (2^B)
当loadFactor为6.5的时候就要扩容。</p>
<h2 id="相同容量扩容">相同容量扩容</h2>
<p>所谓的相同容量扩容，说白了就是不增加bucket的数量，只是整理现在的数据分布。</p>
<p>相同容量扩容的原因是overflow 的 bucket 数量过多：
当 B 小于 15，如果 overflow 的 bucket 数量超过 2^B ；当 B &gt;= 15，如果 overflow 的 bucket 数量超过 2^15 。</p>
<p>其实就是map元素本身不多（达不到加载因子的条件），但是有的bucket的溢出桶overflow太多，这样就造成效率低下。</p>
<p>这样的场景好理解：先添加一些元素，对前面的bucket元素删除，这样就造成大量的bucket不满，整理后可以提高效率。</p>
<h2 id="扩容流程">扩容流程</h2>
<h3 id="等量扩容流程">等量扩容流程</h3>
<p>其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。</p>
<h3 id="2倍的扩容流程">2倍的扩容流程</h3>
<p>元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。</p>
<p>2倍扩容流程，原来的一个bucket会裂变成两个bucket，理由很简单，多看了一位，该位0或1。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic2.png"
        data-srcset="./pic2.png, ./pic2.png 1.5x, ./pic2.png 2x"
        data-sizes="auto"
        alt="./pic2.png"
        title="./pic2.png" /></p>
<p>不管哪种方式，确定扩容的数量后，扩容本身是慢慢的过程。真正搬迁 buckets 的动作在 growWork() 函数中，而调用 growWork() 函数的动作是在 mapassign 和 mapdelete 函数中。**也就是<code>插入</code>或<code>修改</code>、<code>删除 key</code> 的时候，都会尝试进行搬迁 buckets 的工作。**先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p>
<h1 id="put">put</h1>
<ol>
<li>
<p>hash表如果正在扩容，并且这次要操作的bucket还没搬到新hash表中，那么先进行搬迁（扩容细节下面细说）。</p>
</li>
<li>
<p>在buck中寻找key，同时记录下第一个空位置，如果找不到，那么就在空位置中插入数据；如果找到了，那么就更新对应的value；</p>
</li>
<li>
<p>找不到key就看下需不需要扩容，需要扩容并且没有正在扩容，那么就进行扩容，然后回到第一步。</p>
</li>
<li>
<p>找不到key，不需要扩容，但是没有空slot，那么就分配一个overflow bucket挂在链表结尾，用新bucket的第一个slot放存放数据。</p>
</li>
</ol>
<p>向map插入数据，第一步还是先找bucket，对key取hash，低位找桶，再遍历桶中的数据，如果已经满了就新增一个溢出桶挂上去，如果不满就插入即可。</p>
<p>有一个细节注意，只有进行完了这个搬迁操作后，我们才能放心地在新 bucket 里定位 key 要安置的地址，再进行之后的操作。
找到桶后，应该先看下该桶对应的原始桶是否已经迁移完毕，如果还没迁移完毕，就应该先迁移，然后插入之前再看是否需要扩容（不用担心迁移过程中又要扩容，前面有条件），不需要的话再插。</p>
<h1 id="get">get</h1>
<ol>
<li>
<p>先定位出bucket，如果正在扩容，并且这个bucket还没搬到新的hash表中，那么就从老的hash表中查找。</p>
</li>
<li>
<p>在bucket中进行顺序查找，使用高八位进行快速过滤，高八位相等，再比较key是否相等，找到就返回value。如果当前bucket找不到，就往下找overflow bucket，都没有就返回零值。</p>
</li>
</ol>
<p>这里我们可以看到，访问的时候，并不进行扩容的数据搬迁。</p>
<h1 id="delete">delete</h1>
<ol>
<li>
<p>如果正在扩容，并且操作的bucket还没搬迁完，那么搬迁bucket。</p>
</li>
<li>
<p>找出对应的key，如果key、value是包含指针的那么会清理指针指向的内存，否则不会回收内存。</p>
</li>
</ol>
<h1 id="其他">其他</h1>
<ul>
<li>
<p>bucket中key为何不直接和value放一起？
之所以把所有k1k2放一起而不是k1v1是因为key和value的数据类型内存大小可能差距很大，比如map[int64]int8，考虑到字节对齐，kv存在一起会浪费很多空间。</p>
</li>
<li>
<p>map遍历为何无序？
map里的数据如果不进行操作，每次遍历应该是一样的，但是扩容以后就会变化。为了统一记忆，所有遍历都是无序。
实现方案就是每次遍历随机指定bucket和bucket中的key offset，这样遍历的位置就是随机的了。</p>
</li>
<li>
<p>map是否线程安全？
不是的，对同一map进行写，会抛异常。</p>
</li>
<li>
<p>map的key限制
map的key不能是切片、map、函数。可以为interface{},但是运行时还是不能放这三种；key可以为数组，同样数组元素也不能为这三种。总之，key一定可以是“可比较”类型即可以使用==判断，nil==nil是不合法的，所以map不支持key为nil。另外
map的key占用空间越小，hash的速度越快，操作起来也是更快，尽量别用自定义类型</p>
</li>
<li>
<p>历史版本
在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后，并发地读写map会报错。牵涉到并发，应该用sync.map</p>
</li>
<li>
<p>map桶的数量是2^N，为何一定要是2的指数次幂？
在定位桶即tab的index时，一般是取余，hashCode % length,但是取余是复杂的操作，当length为2^N时，hashCode % length == hashCode &amp; (length - 1)，这样就转为了更快的与运算。</p>
</li>
</ul>
<h1 id="总结">总结</h1>
<p>map的赋值（增和改）会造成扩容。
map扩容和迁移是分开的，迁移是渐进的，map的增，删，改都会进行迁移操作，查找并不能进行数据的搬迁。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2017-05-05</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/golang/">golang</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/go_slice/" class="prev" rel="prev" title="golang slice"><i class="fas fa-angle-left fa-fw"></i>golang slice</a>
            <a href="/posts/go_channel/" class="next" rel="next" title="go channel">go channel<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2017-05-05T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"go map"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
