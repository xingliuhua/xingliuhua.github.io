<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>docker - xlh博客</title><meta name="Description" content="docker"><meta property="og:title" content="docker" />
<meta property="og:description" content="docker" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/docker/" />
<meta property="og:image" content="https://xingliuhua.github.io/logo.png"/>
<meta property="article:published_time" content="2019-05-20T17:55:28+08:00" />
<meta property="article:modified_time" content="2019-05-20T17:55:28+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="docker"/>
<meta name="twitter:description" content="docker"/>
<meta name="application-name" content="xlh博客">
<meta name="apple-mobile-web-app-title" content="xlh博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/docker/" /><link rel="prev" href="https://xingliuhua.github.io/posts/git/" /><link rel="next" href="https://xingliuhua.github.io/posts/docker-compose/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "docker",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/docker\/"
        },"genre": "posts","keywords": "docker","wordcount":  4866 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/docker\/","datePublished": "2019-05-20T17:55:28+08:00","dateModified": "2019-05-20T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xlh"},"author": {
                "@type": "Person",
                "name": "xlh"
            },"description": "docker"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xlh博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xlh</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xlh博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xlh</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">docker</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xlh</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2019-05-20">2019-05-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4866 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 10 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li>
          <ol>
            <li><a href="#镜像">镜像</a>
              <ol>
                <li><a href="#镜像管理">镜像管理</a>
                  <ol>
                    <li><a href="#获取镜像">获取镜像</a></li>
                    <li><a href="#镜像的运行">镜像的运行</a></li>
                  </ol>
                </li>
                <li><a href="#列出镜像">列出镜像</a></li>
                <li><a href="#删除镜像">删除镜像</a></li>
                <li><a href="#commit镜像">commit镜像</a></li>
                <li><a href="#dockerfile定制镜像">dockerfile定制镜像</a></li>
                <li><a href="#from-命令">FROM 命令</a></li>
                <li><a href="#run-执行命令">RUN 执行命令</a></li>
                <li><a href="#addcopy">ADD，COPY</a></li>
                <li><a href="#cmd容器启动命令">CMD容器启动命令</a></li>
                <li><a href="#entrypoint-入口点">ENTRYPOINT 入口点</a></li>
                <li><a href="#env-设置环境变量">ENV 设置环境变量</a></li>
                <li><a href="#expose-声明端口">EXPOSE 声明端口</a></li>
                <li><a href="#workdir-指定工作目录">WORKDIR 指定工作目录</a></li>
                <li><a href="#user-指定当前用户">USER 指定当前用户</a></li>
                <li><a href="#volume-定义匿名卷">VOLUME 定义匿名卷</a></li>
                <li><a href="#构建镜像">构建镜像</a></li>
              </ol>
            </li>
            <li><a href="#容器">容器</a>
              <ol>
                <li><a href="#启动容器">启动容器</a>
                  <ol>
                    <li><a href="#新建并启动">新建并启动</a></li>
                    <li><a href="#启动已终止容器">启动已终止容器</a></li>
                    <li><a href="#查看容器列表">查看容器列表</a></li>
                    <li><a href="#终止容器">终止容器</a></li>
                    <li><a href="#进入容器">进入容器</a></li>
                    <li><a href="#删除容器">删除容器</a></li>
                  </ol>
                </li>
              </ol>
            </li>
            <li><a href="#registry">registry</a></li>
            <li><a href="#数据卷">数据卷</a>
              <ol>
                <li><a href="#新增数据卷">新增数据卷</a></li>
                <li><a href="#查看数据卷列表">查看数据卷列表</a></li>
                <li><a href="#使用数据卷">使用数据卷</a></li>
                <li><a href="#删除数据卷">删除数据卷</a></li>
              </ol>
            </li>
            <li><a href="#容器互联">容器互联</a>
              <ol>
                <li><a href="#link">link</a></li>
                <li><a href="#network">network</a>
                  <ol>
                    <li><a href="#none-网络">none 网络</a></li>
                    <li><a href="#host-网络">host 网络</a></li>
                    <li><a href="#bridge-网络">bridge 网络</a></li>
                  </ol>
                </li>
                <li><a href="#新建网络">新建网络</a></li>
                <li><a href="#查看网络">查看网络</a></li>
                <li><a href="#连接容器">连接容器</a>
                  <ol>
                    <li><a href="#ip通信">ip通信</a></li>
                    <li><a href="#docker-dns-server通信">Docker DNS Server通信</a></li>
                    <li><a href="#joined-容器通信">joined 容器通信</a></li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h3 id="镜像">镜像</h3>
<p>对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p>
<h4 id="镜像管理">镜像管理</h4>
<h5 id="获取镜像">获取镜像</h5>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
</code></pre></div><p>命令举例：docker pull ubuntu:18.04</p>
<h5 id="镜像的运行">镜像的运行</h5>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">docker run -it --rm <span class="k">\</span>
    ubuntu:18.04 <span class="k">\</span>
    bash
</code></pre></div><p>docker run其实是运行容器的命令。</p>
<p>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</p>
<p>&ndash;rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 &ndash;rm 可以避免浪费空间。</p>
<p>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。</p>
<p>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p>
<h4 id="列出镜像">列出镜像</h4>
<p>docker image ls
列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p>
<p>可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。docker system df</p>
<p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 none。由于镜像出现了同名或者镜像更新就会出现，可以删除。
镜像是分层的，相同的层只会存一遍。</p>
<h4 id="删除镜像">删除镜像</h4>
<p>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; &hellip;]
其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名</p>
<p>如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。应该先删除容器，再删除镜像。</p>
<h4 id="commit镜像">commit镜像</h4>
<p>对运行中的容器继续一些修改，比如:
docker exec -it webserver bash通过bash进行一些系统的修改，我们可以使用docker commit命令对容器进行保存为镜像，以后启动该镜像就可以是修改后了。</p>
<p>但是，<code>不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。</code>慎用docker commit。</p>
<h4 id="dockerfile定制镜像">dockerfile定制镜像</h4>
<p>如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<h4 id="from-命令">FROM 命令</h4>
<p>FROM 指定基础镜像。
所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。</p>
<p>Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。比如go程序就可以直接在系统上运行。</p>
<h4 id="run-执行命令">RUN 执行命令</h4>
<p>dockerfile中每一个指令都会建立一层，run也是，所以我们合起来，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">FROM debian:stretch

RUN buildDeps=&#39;gcc libc6-dev make wget&#39; <span class="k">\</span>
    <span class="nb">&amp;&amp;</span> apt-get update <span class="k">\</span>
    <span class="nb">&amp;&amp;</span> apt-get install -y <span class="s">$</span><span class="nb">buildDeps </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; wget </span><span class="o">-</span><span class="nb">O redis.tar.gz &#34;http:</span><span class="o">//</span><span class="nb">download.redis.io</span><span class="o">/</span><span class="nb">releases</span><span class="o">/</span><span class="nb">redis</span><span class="o">-</span><span class="m">5</span><span class="nb">.</span><span class="m">0</span><span class="nb">.</span><span class="m">3</span><span class="nb">.tar.gz&#34; </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; mkdir </span><span class="o">-</span><span class="nb">p </span><span class="o">/</span><span class="nb">usr</span><span class="o">/</span><span class="nb">src</span><span class="o">/</span><span class="nb">redis </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; tar </span><span class="o">-</span><span class="nb">xzf redis.tar.gz </span><span class="o">-</span><span class="nb">C </span><span class="o">/</span><span class="nb">usr</span><span class="o">/</span><span class="nb">src</span><span class="o">/</span><span class="nb">redis </span><span class="o">--</span><span class="nb">strip</span><span class="o">-</span><span class="nb">components</span><span class="o">=</span><span class="m">1</span><span class="nb"> </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; make </span><span class="o">-</span><span class="nb">C </span><span class="o">/</span><span class="nb">usr</span><span class="o">/</span><span class="nb">src</span><span class="o">/</span><span class="nb">redis </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; make </span><span class="o">-</span><span class="nb">C </span><span class="o">/</span><span class="nb">usr</span><span class="o">/</span><span class="nb">src</span><span class="o">/</span><span class="nb">redis install </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; rm </span><span class="o">-</span><span class="nb">rf </span><span class="o">/</span><span class="nb">var</span><span class="o">/</span><span class="nb">lib</span><span class="o">/</span><span class="nb">apt</span><span class="o">/</span><span class="nb">lists</span><span class="o">/*</span><span class="nb"> </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; rm redis.tar.gz </span><span class="err">\</span><span class="nb">
</span><span class="nb">    &amp;&amp; rm </span><span class="o">-</span><span class="nb">r </span><span class="o">/</span><span class="nb">usr</span><span class="o">/</span><span class="nb">src</span><span class="o">/</span><span class="nb">redis </span><span class="err">\</span><span class="nb">
</span></code></pre></div><p>dockerfile支持shell类的行尾添加\命令来换行，这样可读性更高。</p>
<h4 id="addcopy">ADD，COPY</h4>
<p>add和copy功能类似，都是把上下文中的文件拷贝到目的路径，add是更高级一点。
因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h4 id="cmd容器启动命令">CMD容器启动命令</h4>
<p>用来指定容器启动时运行的命令
CMD 指令的格式和 RUN 相似，也是两种格式：
shell 格式：CMD &lt;命令&gt;
exec 格式：CMD [&ldquo;可执行文件&rdquo;, &ldquo;参数1&rdquo;, &ldquo;参数2&rdquo;&hellip;]
参数列表格式：CMD [&ldquo;参数1&rdquo;, &ldquo;参数2&rdquo;&hellip;]</p>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &ldquo;，而不要使用单引号。
shell格式其实执行的时候也是变为
CMD [ &ldquo;sh&rdquo;,&quot;-c&rdquo;,&ldquo;echo &hellip;&quot;]</p>
<p><code>注意：cmd命令如果有多个，只有最后的那个有效。另外，当docker run的时候后面指定了要运行的命令，那么cmd就被替代了。</code></p>
<p><code>docker容器没有后台服务的概念，因为他不是虚拟机或物理机。</code></p>
<h4 id="entrypoint-入口点">ENTRYPOINT 入口点</h4>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 &ndash;entrypoint 来指定。</p>
<p><code>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令。</code></p>
<h4 id="env-设置环境变量">ENV 设置环境变量</h4>
<p>格式有两种：</p>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">ENV &lt;key&gt; &lt;value&gt;
ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...
</code></pre></div><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量</p>
<h4 id="expose-声明端口">EXPOSE 声明端口</h4>
<p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;&hellip;]。
EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。</p>
<p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h4 id="workdir-指定工作目录">WORKDIR 指定工作目录</h4>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<p>如果不用workdir，而是cd来切换，那么下一个行的命令又是新的一层镜像，就失效了。</p>
<h4 id="user-指定当前用户">USER 指定当前用户</h4>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。</p>
<h4 id="volume-定义匿名卷">VOLUME 定义匿名卷</h4>
<p>容器的存储默认会随着容器消失而消失，不过我们可以定义数据卷，写到这里的数据是持久的，多个容器可以使用一个数据卷。
格式为：
VOLUME [&ldquo;&lt;路径1&gt;&rdquo;, &ldquo;&lt;路径2&gt;&rdquo;&hellip;]
VOLUME &lt;路径&gt;</p>
<p>命令举例：
VOLUME /data
这样写入到/data的数据就能保留了。
<code>注意：docker run -v /mydata:/data也可以指定数据卷，会覆盖这里的数据卷设置</code></p>
<h4 id="构建镜像">构建镜像</h4>
<p>docker build -t nginx:v3 .
-t 镜像名字及版本
最后一个点代表当前目录是上下文目录，在dockerfile中的copy等命令中的相对目录。</p>
<h3 id="容器">容器</h3>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，<code>就好像是在一个独立于宿主的系统下操作一样。</code></p>
<p>容器有容器存储层，但是容器消亡时，容器存储层也随之消亡。</p>
<p>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<h4 id="启动容器">启动容器</h4>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<h5 id="新建并启动">新建并启动</h5>
<p>docker run -t -i ubuntu:18.04 /bin/bash
-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上。
-i 则让容器的标准输入保持打开。
&ndash;name 给容器起名，后面可以根据名字对容器操作，比较方便。
-p 映射容器与su&rsquo;zhu</p>
<h5 id="启动已终止容器">启动已终止容器</h5>
<p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p>
<p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。
<code>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</code></p>
<h5 id="查看容器列表">查看容器列表</h5>
<p>docker container ls -a</p>
<h5 id="终止容器">终止容器</h5>
<p>可以使用 docker container stop 来终止一个运行中的容器。</p>
<h5 id="进入容器">进入容器</h5>
<p>在使用 -d 参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，可以使用docker exec命令。
docker exec -i 69d1 bash</p>
<p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。
exit退出与容器的交互，容器不停止。</p>
<h5 id="删除容器">删除容器</h5>
<p>可以使用 docker container rm 来删除一个处于终止状态的容器。
docker container prune删除所有终止状态的容器。</p>
<h3 id="registry">registry</h3>
<p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。最常使用的 Registry 公开服务是官方的 Docker Hub。</p>
<p>ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p>
<h3 id="数据卷">数据卷</h3>
<p>数据卷的作用就是对数据持久化， 不然数据随着容器的消失而消失。</p>
<h4 id="新增数据卷">新增数据卷</h4>
<p>docker volume create my-vol</p>
<h4 id="查看数据卷列表">查看数据卷列表</h4>
<p>docker volume ls</p>
<h4 id="使用数据卷">使用数据卷</h4>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">docker run -d -P <span class="k">\</span>
    --name web <span class="k">\</span>
    # -v my-vol:/wepapp <span class="k">\</span>
    --mount source=my-vol,target=/webapp <span class="k">\</span>
    training/webapp <span class="k">\</span>
    python app.py
</code></pre></div><h4 id="删除数据卷">删除数据卷</h4>
<p>docker volume rm my-vol</p>
<h3 id="容器互联">容器互联</h3>
<h4 id="link">link</h4>
<p>可以使用 - -link 参数来使容器互联。
随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 &ndash;link 参数。</p>
<p>运行容器的时候指定相同的网络，接口让他们连接。
<code>已经不推荐使用。</code></p>
<h4 id="network">network</h4>
<p>Docker 网络从覆盖范围可分为单个 host 上的容器网络和跨多个 host 的网络
Docker 安装时会自动在 host 上创建三个网络none、host、bridge，我们可用 docker network ls 命令查看。</p>
<h5 id="none-网络">none 网络</h5>
<p>故名思议，none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo，没有其他任何网卡。容器创建时，可以通过 &ndash;network=none 指定使用 none 网络。</p>
<p>比如某个容器的唯一用途是生成随机密码，就可以放到 none 网络中避免密码被窃取。</p>
<h5 id="host-网络">host 网络</h5>
<p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与 host 完全一样。</p>
<p>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。
Docker host 上已经使用的端口就不能再用了。</p>
<h5 id="bridge-网络">bridge 网络</h5>
<p>Docker 安装时会创建一个 命名为 docker0 的 linux bridge。如果不指定&ndash;network，创建的容器默认都会挂到 docker0 上。</p>
<p>bridge 网络配置的 subnet 就是 172.17.0.0/16，并且网关是 172.17.0.1。这个网关在哪儿呢？大概你已经猜出来了，就是 docker0。</p>
<h4 id="新建网络">新建网络</h4>
<p>除了 none, host, bridge 这三个自动创建的网络，用户也可以根据业务需要创建 user-defined 网络。</p>
<p>Docker 提供三种 user-defined 网络驱动：bridge, overlay 和 macvlan。overlay 和 macvlan 用于创建跨主机的网络，</p>
<p>docker network create -d bridge my-net</p>
<p>我们还可以指定ip网段。
只需在创建网段时指定 &ndash;subnet 和 &ndash;gateway
docker network create -d bridge my-net  &ndash;subnet 172.22.16.0/24 &ndash;gateway 172.22.16.1 my-net2</p>
<p>到目前为止，容器的 IP 都是 docker 自动从 subnet 中分配，我们能否指定一个静态 IP 呢？
通过&ndash;ip指定。
docker network create -d bridge my-net  &ndash;ip 172.22.16.8
<code>注意：只有使用 --subnet 创建的网络才能指定静态 IP</code></p>
<h4 id="查看网络">查看网络</h4>
<p>docker network ls
docker network inspect xx //查看xx网络信息</p>
<h4 id="连接容器">连接容器</h4>
<p>同一网络中的容器、网关之间都是可以通信的。不同网络下容器是不能直接通信的。</p>
<h5 id="ip通信">ip通信</h5>
<p>容器就可以通过 IP 交互了。具体做法是在容器创建时通过 &ndash;network 指定相应的网络，或者通过 docker network connect 将现有容器加入到指定网络。
docker run -it &ndash;rm &ndash;name busybox1 &ndash;network my-net busybox sh
docker run -it &ndash;rm &ndash;name busybox2 &ndash;network my-net busybox sh</p>
<h5 id="docker-dns-server通信">Docker DNS Server通信</h5>
<p>通过 IP 访问容器虽然满足了通信的需求，但还是不够灵活。因为我们在部署应用之前可能无法确定 IP，部署之后再指定要访问的 IP 会比较麻烦。对于这个问题，可以通过 docker 自带的 DNS 服务解决。</p>
<p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，使容器可以直接通过“容器名”通信。
给容器起名方法很简单，只要在启动时用 &ndash;name 为容器命名就可以了。
<code>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的。</code></p>
<h5 id="joined-容器通信">joined 容器通信</h5>
<p>joined 容器是另一种实现容器间通信的方式。</p>
<p>joined 容器非常特别，它可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined 容器之间可以通过 127.0.0.1 直接通信。</p>
<p>方法也简单：
先创建一个 httpd 容器，名字为 web1。
docker run -d -it &ndash;name=web1 httpd
然后创建 busybox 容器并通过 &ndash;network=container:web1 指定 jointed 容器为 web1。这样busybox可以使用127.0.0.1访问web1</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2019-05-20</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/docker/">docker</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/git/" class="prev" rel="prev" title="git"><i class="fas fa-angle-left fa-fw"></i>git</a>
            <a href="/posts/docker-compose/" class="next" rel="next" title="docker-compose">docker-compose<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xlh</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2019-05-20T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"docker"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
