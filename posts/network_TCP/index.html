<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>网络—TCP - xingliuhua博客</title><meta name="Description" content="网络—TCP"><meta property="og:title" content="网络—TCP" />
<meta property="og:description" content="网络—TCP" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/network_tcp/" /><meta property="og:image" content="https://xingliuhua.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-01T17:55:28+08:00" />
<meta property="article:modified_time" content="2017-02-01T17:55:28+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="网络—TCP"/>
<meta name="twitter:description" content="网络—TCP"/>
<meta name="application-name" content="xingliuhua博客">
<meta name="apple-mobile-web-app-title" content="xingliuhua博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/network_tcp/" /><link rel="prev" href="https://xingliuhua.github.io/posts/network_udp/" /><link rel="next" href="https://xingliuhua.github.io/posts/network_%E5%88%86%E5%B1%82/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "网络—TCP",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/network_tcp\/"
        },"genre": "posts","keywords": "网络","wordcount":  7548 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/network_tcp\/","datePublished": "2017-02-01T17:55:28+08:00","dateModified": "2017-02-01T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "网络—TCP"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">网络—TCP</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2017-02-01">2017-02-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7548 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li><a href="#tcp是什么">TCP是什么？</a></li>
    <li><a href="#tcp头部">TCP头部</a></li>
    <li><a href="#流量控制的两种方案">流量控制的两种方案。</a></li>
    <li><a href="#tcp怎么保证可靠传输">tcp怎么保证可靠传输？</a></li>
    <li><a href="#超时重传">超时重传</a></li>
    <li><a href="#确认丢失">确认丢失</a></li>
    <li><a href="#确认迟到">确认迟到</a></li>
    <li><a href="#窗口">窗口</a></li>
    <li><a href="#流量控制">流量控制</a></li>
    <li><a href="#拥塞控制">拥塞控制</a>
      <ol>
        <li><a href="#慢开始和拥塞避免">慢开始和拥塞避免</a></li>
        <li><a href="#快重传">快重传</a></li>
        <li><a href="#快恢复">快恢复</a></li>
      </ol>
    </li>
    <li><a href="#流量控制和拥塞控制有啥区别">流量控制和拥塞控制有啥区别？</a></li>
    <li><a href="#三次握手">三次握手</a></li>
    <li><a href="#四次挥手">四次挥手</a></li>
    <li><a href="#粘包拆包产生的原因">粘包、拆包产生的原因</a></li>
    <li><a href="#syn-flood洪泛攻击">SYN Flood洪泛攻击</a></li>
    <li><a href="#面试问题">面试问题</a></li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><h1 id="tcp是什么">TCP是什么？</h1>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h1 id="tcp头部">TCP头部</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./tcp%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f.png"
        data-srcset="./tcp%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f.png, ./tcp%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f.png 1.5x, ./tcp%e9%a6%96%e9%83%a8%e6%a0%bc%e5%bc%8f.png 2x"
        data-sizes="auto"
        alt="./tcp首部格式.png"
        title="./tcp首部格式.png" /></p>
<p>主要字段的作用：</p>
<ul>
<li>Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li>
<li>Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li>
<li>Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，比如收到了12345这5个字节的数据，序列号是1，那确认序列号就是6，因为下次需要从第6个字节发了。因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li>
<li>Offset:首部长度，或者理解为数据部分距离整个tcp报文开始的偏移量，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最大能表示15，但这里1代表4个字节，即首部长度为4*15=60个字节），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li>
<li>TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下：</li>
<li>URG：发送端的缓存窗口中的数据是顺序发送，如果想插队先发送这段数据，可设置该标志位1。配合紧急指针使用。</li>
<li>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；连接建立后ACK都要是1。</li>
<li>PUSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队,意思就是在接收端进行插队，可以和URG类比记忆。</li>
<li>RST：发生了异常，需要重新建立链接。</li>
<li>SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</li>
<li>FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li>
<li>窗口：表示我本地的接收缓存窗口还能接收多少数据。</li>
<li>可选项：最大报文段长度MSS等。</li>
</ul>
<h1 id="流量控制的两种方案">流量控制的两种方案。</h1>
<p>停止等待协议和滑动窗口协议。
停止等待就是A发给B，B收到后回复确认，A收到后再发。A收到确认之前是要停止等待的，所以效率比较低，早期链路层就是这样的。
第二种方案是滑动窗口，连续发多个，如果有丢失的怎么办？两种方案1.选择重传方案（SR)tcp默认也是这样的。。2.回退N帧方案（GBN)。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%9e%e9%80%80N%e5%b8%a7.png"
        data-srcset="./%e5%9b%9e%e9%80%80N%e5%b8%a7.png, ./%e5%9b%9e%e9%80%80N%e5%b8%a7.png 1.5x, ./%e5%9b%9e%e9%80%80N%e5%b8%a7.png 2x"
        data-sizes="auto"
        alt="./回退N帧.png"
        title="Alt text" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e9%80%89%e6%8b%a9%e9%87%8d%e4%bc%a0.png"
        data-srcset="./%e9%80%89%e6%8b%a9%e9%87%8d%e4%bc%a0.png, ./%e9%80%89%e6%8b%a9%e9%87%8d%e4%bc%a0.png 1.5x, ./%e9%80%89%e6%8b%a9%e9%87%8d%e4%bc%a0.png 2x"
        data-sizes="auto"
        alt="./选择重传.png"
        title="Alt text" /></p>
<p>另外tcp还有个优化就是快重传，不用等到超时到期就能知道丢失了。</p>
<h1 id="tcp怎么保证可靠传输">tcp怎么保证可靠传输？</h1>
<p>校验、序号、确认、重传。</p>
<p>Tcp的确认默认是累计重传。即接收方回复ack号是n,说明n号之前的数据都已经接收成功了。</p>
<h1 id="超时重传">超时重传</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1538277874498.png"
        data-srcset="./1538277874498.png, ./1538277874498.png 1.5x, ./1538277874498.png 2x"
        data-sizes="auto"
        alt="./1538277874498.png"
        title="Alt text" /></p>
<p>如图所示，接收方接收到数据后要给客户端响应，来告诉别人自己收到了数据。
如果压根就没发到服务端，肯定不会收到服务端的响应，客户端等，等到超时后重传上个丢失的数据。
超时时间是动态的。</p>
<h1 id="确认丢失">确认丢失</h1>
<p>客户端成功发M1到服务端，服务端响应确认，但是确认包丢失了，客户端一样还会等，重传M1，这时候服务端收到了重复的数据，就会舍弃第二次收到的包，并再发对M1的响应。</p>
<h1 id="确认迟到">确认迟到</h1>
<p>客户端在发送数据M1后，服务端发送响应，但是迟到了，客户端没有及时收到响应，超时后重发，服务端舍弃重复收到的数据并响应M1,此时客户端收到迟到的响应，并舍弃响应。</p>
<h1 id="窗口">窗口</h1>
<p>客户端每次发送后，服务端对其响应，没有收到响应时会等待并重发。这样效率是低下的，由此引入“窗口”来提高效率。
简单来说，在窗口范围内不用先等上次的响应，继续发下面的内容。服务端没有收到数据时会告诉客户端重发。客户端连续三次收到重发标示就会重发失败的数据。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1538288992405.png"
        data-srcset="./1538288992405.png, ./1538288992405.png 1.5x, ./1538288992405.png 2x"
        data-sizes="auto"
        alt="./1538288992405.png"
        title="Alt text" /></p>
<blockquote>
<p>发送窗口=min{接收窗口rwnd,拥塞窗口cwnd)
接收窗口：接收方根据接受缓存设置的值，并告知发送方，反映接收方容量。
拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。
发送端有发送缓存窗口，接收端有接收缓存窗口。</p>
</blockquote>
<h1 id="流量控制">流量控制</h1>
<p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>在通信过程中，接收方根据自己的接收缓存大小、动态地调整发送窗口大小，即接收窗口rwnd(receive window接收方设置确认报文段的窗口字段来将rwnd通知给发送方),发送方的发送窗口取决于接收窗口rwnd和拥塞窗口cwnd的最小值）。</p>
<p>设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。</p>
<p>TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<code>控测报文</code>段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器</p>
<h1 id="拥塞控制">拥塞控制</h1>
<h2 id="慢开始和拥塞避免">慢开始和拥塞避免</h2>
<p>上面讲到，窗口可以提高传输效率，但是刚开始窗口就比较大，就很可能造成堵塞。所以提出一个慢启动的概念,即刚开始还是先发送1个，慢慢增加这就是<strong>慢开始</strong>，2个、4个、8个、这样指数型增长，指数增长速度极快，到达一个点后，开始慢速增长，就是为了<strong>拥塞避免</strong>，这时候换成线性增长，一次增加一个。我们把这个转换的转折点叫做门限ssthresh。发送方维持一个叫做拥塞窗口 cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic3.png"
        data-srcset="./pic3.png, ./pic3.png 1.5x, ./pic3.png 2x"
        data-sizes="auto"
        alt="./pic3.png"
        title="Alt text" /></p>
<p>我们图中可以看到，门限变为拥塞窗口的一半，再从1开始慢慢增加。</p>
<p>问题来了，如果网络一直不拥塞就可以一直增大吗？不会，发送的窗口大小还要受接收窗口rwnd大小的限制，所以
客户端发送窗口的上限 = min(rwnd,cwnd)</p>
<h2 id="快重传">快重传</h2>
<p>又一个问题来了，怎么及时知道网络拥塞了？
快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。每当比期望序号大的失序报文到达时，就发送ack号为期望号。
发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。
不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</p>
<h2 id="快恢复">快恢复</h2>
<p>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把<code>慢开始门限 ssthresh</code> 减半。但接下去不执行慢开始算法。
换句话说，拥塞后并不是从1开始慢慢增加，而是从拥塞窗口的一半也就是ssthresh处开始慢慢增加。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic4.png"
        data-srcset="./pic4.png, ./pic4.png 1.5x, ./pic4.png 2x"
        data-sizes="auto"
        alt="./pic4.png"
        title="Alt text" /></p>
<h1 id="流量控制和拥塞控制有啥区别">流量控制和拥塞控制有啥区别？</h1>
<p>流量控制是发送端控制的，根据接收端的情况选择发送速度，原理是通过滑动窗口的大小改变来实现。而拥塞控制是根据的传输线路的拥挤程度来选择发送速度。好比是两个车站间传送货物，一个是根据接收车站的接收效率决定，一个是根据路上的车辆拥挤决定。</p>
<h1 id="三次握手">三次握手</h1>
<p>先举个形象的例子，两个人AB进行电话沟通，为了保证双向是通的，常进行以下对话：</p>
<p><strong>A：你能听到我说话吗？</strong></p>
<p><strong>B：可以，你能听到吗？</strong></p>
<p><strong>A：我也可以。</strong></p>
<p>这样双方就知道无论是“去”还是“来”都是正常的，就可以聊天了。</p>
<p>第一次握手中seq=i的i值是随机的。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.png"
        data-srcset="./%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.png, ./%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.png 1.5x, ./%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.png 2x"
        data-sizes="auto"
        alt="./三次握手.png"
        title="./三次握手.png" /></p>
<h1 id="四次挥手">四次挥手</h1>
<p>Tcp断开连接时需要4次挥手。
还是先举个例子，两个人进行电话沟通时突然有一个想挂断，一般会有如下对话：</p>
<p><strong>A：我不想说了</strong>（第一次挥手。A发送	FIN，表示不A不再说什么事情）</p>
<p><strong>B：好的</strong>	（第二次挥手。B发送ACK表示知道了，但是他可能有话没说话，会继续向A说）</p>
<p>B：对了，还有一个事情我要说完&hellip;（B没说完话的话继续说）</p>
<p><strong>B：说完了，我也不想说了</strong>（第三次挥手。B发送FIN表示他也说完了）</p>
<p><strong>A：好的</strong>（第四次挥手。A发送ACK表示知道了，自此完全断开）</p>
<p>在释放连接时，由于TCP是全双工的，因此最后要由两端分别进行关闭，这个流程如下：</p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&ldquo;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&rdquo;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&ldquo;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&rdquo;。Client端收到FIN报文后，&ldquo;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&ldquo;就知道可以断开连接了&rdquo;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<p>关闭连接有主动关闭和被动关闭一说，这里为了简化理解，我们以客户端作为主动关闭方，服务器为被动关闭方。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b.png"
        data-srcset="./%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b.png, ./%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b.png 1.5x, ./%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b.png 2x"
        data-sizes="auto"
        alt="./四次挥手.png"
        title="./四次挥手.png" /></p>
<p>三次握手，四次挥手完整流程：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./1537948069294.png"
        data-srcset="./1537948069294.png, ./1537948069294.png 1.5x, ./1537948069294.png 2x"
        data-sizes="auto"
        alt="./1537948069294.png"
        title="./1537948069294.png" /></p>
<p>整个过程Client端所经历的状态如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic1.gif"
        data-srcset="./pic1.gif, ./pic1.gif 1.5x, ./pic1.gif 2x"
        data-sizes="auto"
        alt="./pic1.gif"
        title="./pic1.gif" /></p>
<p>而Server端所经历的过程如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./pic2.gif"
        data-srcset="./pic2.gif, ./pic2.gif 1.5x, ./pic2.gif 2x"
        data-sizes="auto"
        alt="./pic2.gif"
        title="./pic2.gif" /></p>
<p>【注意】 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p>
<p>我们不仅疑问，为啥断开的时候会比握手的时候多一次？
第二次握手时，SYN+ACK其实可以放一起，但是第二次挥手时ACK 和 ACK却不能放一起，因为B也许有话没说完</p>
<h1 id="粘包拆包产生的原因">粘包、拆包产生的原因</h1>
<p>粘包、拆包问题的产生原因笔者归纳为以下3种：</p>
<ol>
<li>socket缓冲区与滑动窗口</li>
<li>MSS/MTU限制</li>
<li>Nagle算法</li>
</ol>
<p><strong>socket缓冲区与滑动窗口</strong></p>
<p>每个TCP socket在内核中都有一个发送缓冲区(SO_SNDBUF )和一个接收缓冲区(SO_RCVBUF)，TCP的全双工的工作模式以及TCP的滑动窗口便是依赖于这两个独立的buffer的填充状态。</p>
<p>SO_SNDBUF：</p>
<p>进程发送的数据的时候假设调用了一个send方法，最简单情况(也是一般情况)，将数据拷贝进入socket的内核发送缓冲区之中，然后send便会在上层返回。换句话说，send返回之时，数据不一定会发送到对端去(和write写文件有点类似)，send仅仅是把应用层buffer的数据拷贝进socket的内核发送buffer中。</p>
<p>SO_RCVBUF：</p>
<p>把接受到的数据缓存入内核，应用进程一直没有调用read进行读取的话，此数据会一直缓存在相应socket的接收缓冲区内。再啰嗦一点，不管进程是否读取socket，对端发来的数据都会经由内核接收并且缓存到socket的内核接收缓冲区之中。read所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的buffer里面，仅此而已。</p>
<p>滑动窗口：</p>
<p>TCP连接在三次握手的时候，会将自己的窗口大小(window size)发送给对方，其实就是SO_RCVBUF指定的值。之后在发送数据的时，发送方必须要先确认接收方的窗口没有被填充满，如果没有填满，则可以发送。</p>
<p>每次发送数据后，发送方将自己维护的对方的window size减小，表示对方的SO_RCVBUF可用空间变小。</p>
<p>当接收方处理开始处理SO_RCVBUF 中的数据时，会将数据从socket 在内核中的接受缓冲区读出，此时接收方的SO_RCVBUF可用空间变大，即window size变大，接受方会以ack消息的方式将自己最新的window size返回给发送方，此时发送方将自己的维护的接受的方的window size设置为ack消息返回的window size。</p>
<p>此外，发送方可以连续的给接受方发送消息，只要保证对方的SO_RCVBUF空间可以缓存数据即可，即window size&gt;0。当接收方的SO_RCVBUF被填充满时，此时window size=0，发送方不能再继续发送数据，要等待接收方ack消息，以获得最新可用的window size。</p>
<p><strong>MSS/MTU分片</strong></p>
<p>MTU (Maxitum Transmission Unit,最大传输单元)是链路层对一次可以发送的最大数据的限制。MSS(Maxitum Segment Size,最大分段大小)是TCP报文中data部分的最大长度，是传输层对一次可以发送的最大数据的限制。</p>
<h1 id="syn-flood洪泛攻击">SYN Flood洪泛攻击</h1>
<p>原理：攻击者首先伪造地址对 服务器发起SYN请求，服务器回应(SYN+ACK)包，而真实的IP会认为，我没有发送请求，不作回应。服务 器没有收到回应，这样的话，服务器不知 道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者 如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。</p>
<p>linux内核参数调优主要有下面三个：</p>
<ul>
<li>tcp_max_syn_backlog
从字面上就可以推断出是什么意思。在内核里有个队列用来存放还没有确认ACK的客户端请求，当等待的请求数大于tcp_max_syn_backlog时，后面的会被丢弃。
所以，适当增大这个值，可以在压力大的时候提高握手的成功率。手册里推荐大于1024。</li>
<li>tcp_synack_retries
这个是三次握手中，服务器回应ACK给客户端里，重试的次数。默认是5。显然攻击者是不会完成整个三次握手的，因此服务器在发出的ACK包在没有回应的情况下，会重试发送。当发送者是伪造IP时，服务器的ACK回应自然是无效的。
为了防止服务器做这种无用功，可以把tcp_synack_retries设置为0或者1。因为对于正常的客户端，如果它接收不到服务器回应的ACK包，它会再次发送SYN包，客户端还是能正常连接的，只是可能在某些情况下建立连接的速度变慢了一点。</li>
<li>tcp_syncookies
Linux中SYN cookie是非常巧妙地利用了TCP规范来绕过了TCP连接建立过程的验证过程，从而让服务器的负载可以大大降低。
在三次握手中，当服务器回应（SYN + ACK）包后，客户端要回应一个n + 1的ACK到服务器。其中n是服务器自己指定的。当启用tcp_syncookies时，linux内核生成一个特定的n值，而不<strong>并把客户的连接放到半连接的队列里</strong>（即没有存储任何关于这个连接的信息）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。</li>
</ul>
<h1 id="面试问题">面试问题</h1>
<p><code>问题1. 为什么是四次挥手</code></p>
<p>发送FIN的一方就是主动关闭(客户端)，而另一方则为被动关闭(服务器)。当一方发送了FIN，则表示在这一方不再会有数据的发送。其中当被动关闭方受到对方的FIN时，此时往往可能还有数据需要发送过去，因此无法立即发送FIN(也就是无法将FIN与ACK合并发送)， 而是在等待自己的数据发送完毕后再单独发送FIN，因此整个过程需要四次交互。</p>
<p><code>问题2. 什么是半关闭</code></p>
<p>客户端在收到第一个FIN的ACK响应后，会进入FINWAIT2 状态时，此时服务器处于 CLOSEWAIT状态，这种状态就称之为半关闭。从半关闭到全关闭，需要等待第二次FIN的确认才算结束。此时，客户端要等到服务器的FIN才能进入TIMEWAIT， 如果对方迟迟不发送FIN呢，则会等待一段时间后超时，这个可以通过内核参数tcpfin_timeout控制，默认是60s。</p>
<p><code>问题3. RST 是什么，为什么会出现</code></p>
<p>RST 是一个特殊的标记，用来表示当前应该立即终止连接。以下这些情况都会产生RST：</p>
<p>向一个未被监听的端口发送数据
对方已经调用 close 关闭连接
存在一些数据未处理(接收缓冲区)，请求关闭连接时，会发送RST强制关闭
某些请求发生了超时</p>
<p><code>题4.为什么需要TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</code></p>
<p>答：TIME_WAIT是主动提出结束的一方的状态，对方发送FIN说“我也说完了”，这边回应ACK，但是这个ACK可能会丢失，那么对方就会以为你没有收到，他会重发。如果不经历2MSL直接进入CLOSE状态，新的连接建立后，你会莫名收到一个FIN。</p>
<p>四次挥手中，A 发 FIN， B 响应 ACK，B 再发 FIN，A 响应 ACK 实现连接的关闭。而如果 A 响应的 ACK 包丢失，B 会以为 A 没有收到自己的关闭请求，然后会重试向 A 再发 FIN 包。</p>
<p>如果没有 TIME_WAIT 状态，A 不再保存这个连接的信息，收到一个不存在的连接的包，A 会响应 RST 包，导致 B 端异常响应。</p>
<p>此时， TIME_WAIT 是为了保证全双工的 TCP 连接正常终止。</p>
<p><code>题5.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？一个MSL行不行？</code></p>
<p>答：一个不行。</p>
<p>最大分段寿命（MSL, Maximum Segment Lifetime），它表示一个 TCP 分段可以存在于互联网系统中的最大时间，由 TCP 的实现，超出这个寿命的分片都会被丢弃。</p>
<p>A主动提出结束。第四次挥手，A向B回复 ack。B如果没有收到会重发FIN，所以A要等待足够的时间来判断B会不会发FIN。</p>
<p>A并不知道B是否接到自己的ACK，A是这么想的：
1）如果B没有收到自己的ACK，会超时重传FiN那么A再次接到重传的FIN，会再次发送ACK
2）如果B收到自己的ACK，也不会再发任何消息，包括ACK
无论是1还是2，A都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这恰恰就是2MSL( Maximum Segment Life)。</p>
<p>参考文章：
<a href="https://blog.csdn.net/Neo233/article/details/72866230" target="_blank" rel="noopener noreffer">https://blog.csdn.net/Neo233/article/details/72866230</a>
<a href="https://blog.csdn.net/hacker00011000/article/details/52319111" target="_blank" rel="noopener noreffer">https://blog.csdn.net/hacker00011000/article/details/52319111</a>
<a href="https://www.zhihu.com/question/67013338/answer/248375813" target="_blank" rel="noopener noreffer">https://www.zhihu.com/question/67013338/answer/248375813</a></p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2017-02-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/network_udp/" class="prev" rel="prev" title="网络—UDP"><i class="fas fa-angle-left fa-fw"></i>网络—UDP</a>
            <a href="/posts/network_%E5%88%86%E5%B1%82/" class="next" rel="next" title="网络_分层">网络_分层<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2017-02-01T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"网络—TCP"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
