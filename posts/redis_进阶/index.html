<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Redis学习（二）-redis进阶 - xingliuhua博客</title><meta name="Description" content="Redis学习（二）-redis进阶"><meta property="og:title" content="Redis学习（二）-redis进阶" />
<meta property="og:description" content="Redis学习（二）-redis进阶" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xingliuhua.github.io/posts/redis_%E8%BF%9B%E9%98%B6/" /><meta property="og:image" content="https://xingliuhua.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-16T17:55:28+08:00" />
<meta property="article:modified_time" content="2017-04-16T17:55:28+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xingliuhua.github.io/logo.png"/>

<meta name="twitter:title" content="Redis学习（二）-redis进阶"/>
<meta name="twitter:description" content="Redis学习（二）-redis进阶"/>
<meta name="application-name" content="xingliuhua博客">
<meta name="apple-mobile-web-app-title" content="xingliuhua博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://xingliuhua.github.io/posts/redis_%E8%BF%9B%E9%98%B6/" /><link rel="prev" href="https://xingliuhua.github.io/posts/redis_%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6/" /><link rel="next" href="https://xingliuhua.github.io/posts/redis_%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Redis学习（二）-redis进阶",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/xingliuhua.github.io\/posts\/redis_%E8%BF%9B%E9%98%B6\/"
        },"genre": "posts","keywords": "redis","wordcount":  5561 ,
        "url": "https:\/\/xingliuhua.github.io\/posts\/redis_%E8%BF%9B%E9%98%B6\/","datePublished": "2017-04-16T17:55:28+08:00","dateModified": "2017-04-16T17:55:28+08:00","publisher": {
            "@type": "Organization",
            "name": "xingliuhua"},"author": {
                "@type": "Person",
                "name": "xingliuhua"
            },"description": "Redis学习（二）-redis进阶"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="xingliuhua博客"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/logo.png"
        data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x"
        data-sizes="auto"
        alt="/logo.png"
        title="/logo.png" />xingliuhua</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Redis学习（二）-redis进阶</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://xingliuhua/github.com.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>xingliuhua</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2017-04-16">2017-04-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5561 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ol>
    <li><a href="#redis的配置">redis的配置</a></li>
    <li><a href="#redis持久化">redis持久化</a>
      <ol>
        <li><a href="#快照方式rdb-redis-database">快照方式RDB (Redis Database)</a></li>
        <li><a href="#日志追加方式aofappend-only-file">日志追加方式AOF(Append Only File)</a></li>
        <li><a href="#rdb和aof的优缺点比较">RDB和AOF的优缺点比较</a></li>
      </ol>
    </li>
    <li><a href="#redis主从简介">redis主从简介</a>
      <ol>
        <li><a href="#redis主从原理">redis主从原理</a></li>
      </ol>
    </li>
    <li><a href="#redis事务">redis事务</a>
      <ol>
        <li><a href="#redis事务流程">redis事务流程</a></li>
        <li><a href="#discardwatch命令">DISCARD、WATCH命令</a></li>
        <li><a href="#事务的-acid-性质">事务的 ACID 性质</a>
          <ol>
            <li>
              <ol>
                <li><a href="#原子性atomicity">原子性（Atomicity</a></li>
                <li><a href="#一致性consistency">一致性（Consistency</a></li>
                <li><a href="#隔离性isolation">隔离性（Isolation）</a></li>
                <li><a href="#持久性durability">持久性（Durability）</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#redis淘汰策略">redis淘汰策略</a></li>
  </ol>
</nav></div>
            </div><div class="content" id="content"><p>上篇主要讲到redis的基础命令，这篇涉及到redis的配置、持久化、主从、事务、内存淘汰策略</p>
<h1 id="redis的配置">redis的配置</h1>
<p>启动redis服务器的时候会指定配置文件，主要参数如下：</p>
<ul>
<li><strong>daemonize</strong>： #是否以后台守护进程方式运行</li>
<li><strong>pidfile</strong>： #pid 文件位置</li>
<li><strong>port</strong>： #监听的端口号</li>
<li><strong>timeout</strong>： #请求超时时间</li>
<li><strong>loglevel</strong>： #log 信息级别，总共支持四个级别：debug、verbose、notice、warning ，
默认为 verbose</li>
<li><strong>logfile</strong>： #默认为标准输出（stdout），如果配置为守护进程方式运行，而这里又配
置为日志记录方式为标准输出，则日志将会发送给/dev/null</li>
<li><strong>databases</strong>： #开启数据库的数量。使用“SELECT 库 ID”方式切换操作各个数据库</li>
<li><strong>save</strong>：保存快照的频率，第一个<em>表示多长时间，第二个</em>表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。</li>
<li><strong>rdbcompression</strong>：#保存快照是否使用压缩</li>
<li><strong>dbfilename</strong>： #数据快照文件名（只是文件名，不包括目录）。默认值为 dump.rdb</li>
<li><strong>dir</strong>： #数据快照的保存目录（这个是目录）</li>
<li><strong>requirepass</strong>： #设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需
要通过 AUTH <!-- raw HTML omitted -->命令提供密码，默认关闭。</li>
</ul>
<h1 id="redis持久化">redis持久化</h1>
<p>redis在内存中存储数据，但重启的时候我们还是希望能恢复数据，那么可以把数据持久化到数据库中。<code>你也可以同时开启两种持久化方式， 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</code></p>
<h2 id="快照方式rdb-redis-database">快照方式RDB (Redis Database)</h2>
<p>快照方式也是redis默认使用方式，这种方式就是将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。当然我们也可以主动调用命令来手动持久化，使用save 或者bgsave 命令通知 redis 做一次快照持久化。
配置参数<br>
save 900 1<br>
save 300 10<br>
save 60 10000<br>
分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
<p>RDB文件通过两个命令来生成：</p>
<ul>
<li>
<p>SAVE:阻塞redis的服务器进程，直到RDB文件被创建完毕。在主线程中保存快照，redis是用一个主线程来处理所有请求的，这种方式会阻塞所有客户端的请求。</p>
</li>
<li>
<p>BGSAVE:Fork出一个子进程来创建RDB文件，不阻塞服务器进程，记录接收BGSAVE当时的数据库状态，父进程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程。</p>
</li>
</ul>
<p>自动化触发RDB持久化的方式
1&gt;根据配置redis.conf的save就可以(用的bgsave)
2&gt;主从复制时，主节点自动触发
3&gt;执行Debug Reload
4&gt;执行shutdown且没有开启AOF持久化</p>
<p>注意：</p>
<ul>
<li>save 操作是在主线程中保存快照的，由于 redis 是用一个主线程来处理所有客户端的请求，这种方式会阻塞所有客户端请求。所以不推荐使用。</li>
<li>每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步增量数据。如果数据量大的话，写操作会比较多，必然会引起大量的磁盘 IO 操作，可能会严重影响性能。</li>
</ul>
<h2 id="日志追加方式aofappend-only-file">日志追加方式AOF(Append Only File)</h2>
<p>这种方式 redis 会将每一个收到的写命令都通过 write 函数追加到文件中(默认appendonly.aof)。当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于操作系统会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上。这样的持久化还是有可能会丢失部分修改。不过我们可以通过配置文件告诉redis 我们想要通过 fsync 函数强制操作系统写入到磁盘的时机。有三种方式如下（默认是 ：每秒 fsync 一次）</p>
<ul>
<li>appendonly yes //启用日志追加持久化方式</li>
<li>appendfsync always //每次收到写命令就立即强制写入磁盘，最慢的，但是保证完全
的持久化，不推荐使用</li>
<li>appendfsync everysec //每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折
中，推荐</li>
<li>appendfsync no //完全依赖操作系统，性能最好,持久化没保证</li>
</ul>
<p>日志追加方式同时带来了另一个问题。持久化文件会变的越来越大。为了压缩这种持久化方式的日志文件 。redis 提供了bgrewriteaof 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，而不是把原来那种所有的操作记录，最后替换原来的持久化日志文件。 我们可以配置aof文件的大小扩张倍数即重写。</p>
<p>比如说redis现在做一个定时器，轮询100下，那其实我们想要的结果是最后的数据，但是AOF会把整个过程记录下来，所以AOF文件大小会不断增大。怎么办呢？
BGREWRITEAOF命令来重写
1&gt;调用fork()，创建一个子进程
2&gt;子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
3&gt;主进程持续将新的变动同时写到内存和原来的AOF里
4&gt;主进程获取子进程重写AOF的信号之后，往新的AOF同步增量变动
5&gt;使用新的AOF文件替换旧的AOF文件</p>
<h2 id="rdb和aof的优缺点比较">RDB和AOF的优缺点比较</h2>
<p>1&gt;
RDB优点：全量数据快照，文件小，恢复快
RDB缺点：无法保存最近一次快照之后的数据
2&gt;
AOF优点：可读性高，适合保存增量数据，数据不易丢失
AOF缺点：文件体积大，恢复时间长</p>
<p>RDB-AOF混合
redis4.0之后推出RDB-AOF混合持久化方式，并且是默认配置。
BGSAVE做镜像全量持久化，AOF做增量持久化。
在redis实例重启时，会使用BGSAVE持久化文件重新构建内容，再使用AOF重放近期的操作指令。</p>
<h1 id="redis主从简介">redis主从简介</h1>
<p>Redis 支持将数据同步到多台从库上，这种特性对提高 读取性能非常有益。</p>
<ul>
<li>master 可以有多个 slave。</li>
<li>除了多个 slave 连到相同的 master 外，slave 也可以连接其它 slave 形成图状结构。</li>
<li>主从复制不会阻塞 master。也就是说当一个或多个 slave 与 master 进行初次同步数据<br>
时，master 可以继续处理客户端发来的请求。</li>
<li>主从复制可以用来提高系统的可伸缩性,我们可以用多个 slave 专门用于客户端的读请求，比如 sort 操作可以使用 slave 来处理。也可以用来做简单的数据冗余。</li>
<li>可以在 master 禁用数据持久化，只需要注释掉 master 配置文件中的所有 save 配置，然
后只在 slave 上配置数据持久化</li>
</ul>
<h2 id="redis主从原理">redis主从原理</h2>
<p>当设置好 slave 服务器后，slave 会建立和 master 的连接，然后发送 sync 命令。无论是第一次同步建立的连接还是连接断开后的重新连接，master 都会启动一个后台进程，将数据库快照保存到文件中，同时 master 主进程会开始收集新的写命令并缓存起来。后台进程完成写文件后，master 就发送文件给 slave，slave 将文件保存到磁盘上，然后加载到内存恢复数据库快照到 slave 上。接着 master 就会把缓存的命令转发给 slave。而且后续 master 收到的写命令都会通过开始建立的连接发送给slave。从master到slave的同步数据的命令和从客户端发送的命令使用相同的协议格式。当 master 和 slave 的连接断开时 <code>slave 可以自动重新建立连接。</code>如果 master 同时收到多个 slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有 slave。<br>
配置 slave 服务器很简单，只需要在配置文件中加入如下配置：<br>
slaveof 192.168.1.1 6379 #指定 master 的 ip 和端口</p>
<h1 id="redis事务">redis事务</h1>
<p>如果是在入队时报错，那么都不会执行；比如入队时一个命令参数错误，就会把队列清空，回到正常模式。
exec命令后，开始执行队列中的命令，执行中发生错误,并不会把原来的回滚，而是继续执行后面的命令。</p>
<p>Redis 通过 MULTI 、DISCARD 、EXEC 和 WATCH 四个命令来实现事务功能。<br>
事务提供了一种“将多个命令打包，然后一次性、按顺序地执行”的机制，并且事务在执行的期间不会主动中断——服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令。<br>
另外，<strong>Redis的事务是不可嵌套的</strong>，当客户端已经处于事务状态，而客户端又再向服务器发送 MULTI
时，服务器只是简单地向客户端发送一个错误，然后继续等待其他命令的入队。</p>
<h2 id="redis事务流程">redis事务流程</h2>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol>
<li>开始事务。//MUTI命令，这个命令唯一做的就是，将客户端的 REDIS_MULTI 选项打开，让客户端从非事务状态切换到事务状态。</li>
<li>命令入队。//&hellip;要执行的命令，当客户端处于非事务状态下时，所有发送给服务器端的命令都会立即被服务器执行，但是当客户端进入事务状态之后，服务器在收到来自客户端的命令时，不会立即执行命令，而是将这些命令全部放进一个事务队列里，然后返回 QUEUED ，表示命令已入队。</li>
<li>执行事务。//EXEC命令，前面说到，当客户端进入事务状态之后，客户端发送的命令就会被放进事务队列里。但其实并不是所有的命令都会被放进事务队列，其中的例外就是 EXEC 、DISCARD 、MULTI
和 WATCH 这四个命令——当这四个命令从客户端发送到服务器时，它们会像客户端处于非事务状态一样，直接被服务器执行</li>
</ol>
<h2 id="discardwatch命令">DISCARD、WATCH命令</h2>
<p>DISCARD代表取消事务，它清空客户端的整个事务队列，然后将客户端从事务状态调整回非事务状态，最后返回字符串 OK 给客户端，说明事务已被取消。<br>
WATCH 命令用于在事务开始之前监视任意数量的键：当调用 EXEC 命令执行事务时，如果任意一个被监视的键已经被其他客户端修改了，那么整个事务不再执行，直接返回失败。(不是单线程吗？怎么还有别的客户端改？其实你打开multi开始入队，并不耽误别的客户端改）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">redis</span><span class="p">&gt;</span> <span class="nx">WATCH</span> <span class="nx">name</span>  
</span></span><span class="line"><span class="cl"><span class="nx">OK</span>  
</span></span><span class="line"><span class="cl"><span class="nx">redis</span><span class="p">&gt;</span> <span class="nx">MULTI</span>
</span></span><span class="line"><span class="cl"><span class="nx">OK</span>
</span></span><span class="line"><span class="cl"><span class="nx">redis</span><span class="p">&gt;</span> <span class="nx">SET</span> <span class="nx">name</span> <span class="nx">peter</span>
</span></span><span class="line"><span class="cl"><span class="nx">QUEUED</span>
</span></span><span class="line"><span class="cl"><span class="nx">redis</span><span class="p">&gt;</span> <span class="nx">EXEC</span>
</span></span></code></pre></div><p>当一个客户端结束它的事务时，无论事务是成功执行，还是失败,watch内容都会被清空。</p>
<h2 id="事务的-acid-性质">事务的 ACID 性质</h2>
<p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<h4 id="原子性atomicity">原子性（Atomicity</h4>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以
Redis 事务的执行并不是原子性的。<br>
如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。另一方面，如果 Redis 服务器进程在执行事务的过程中被停止——比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>
<h4 id="一致性consistency">一致性（Consistency</h4>
<p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<ol>
<li>入队错误
在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等，那么服务器将向客户端返回一个出错信息，并且将客户端的事务状态设为REDIS_DIRTY_EXEC，因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</li>
<li>执行错误
如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作，
那么 Redis 只会将错误包含在事务的结果中，这不会引起事务中断或整个失败，不会影响已执
行事务命令的结果，也不会影响后面要执行的事务命令，所以它对事务的一致性也没有影响。</li>
<li>Redis 进程被终结
如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根
据 Redis 所使用的持久化模式，可能有以下情况出现：<br>
• 内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所
以数据总是一致的。<br>
• RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执
行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事
务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。
恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数
据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为
其他问题而出错，那么还原后的数据库就是一致的。<br>
• AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，
保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF
文件，有以下两种情况发生：</li>
</ol>
<ul>
<li>如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进
程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只
要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的
数据不一定是最新的。</li>
<li>如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的
事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不
完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令
移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直
到事务执行之前为止）。</li>
</ul>
<h4 id="隔离性isolation">隔离性（Isolation）</h4>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执
行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h4 id="持久性durability">持久性（Durability）</h4>
<p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事
务的持久性由 Redis 所使用的持久化模式决定</p>
<h1 id="redis淘汰策略">redis淘汰策略</h1>
<p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：</p>
<p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
<p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p>
<p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
<p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p>
<p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
<p>no-enviction（驱逐）：禁止驱逐数据，内存不足就报错（默认的策略）</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2017-04-16</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/redis/">redis</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/redis_%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6/" class="prev" rel="prev" title="Redis学习（三）-redis过期机制"><i class="fas fa-angle-left fa-fw"></i>Redis学习（三）-redis过期机制</a>
            <a href="/posts/redis_%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4/" class="next" rel="next" title="Redis学习-主从、哨兵、集群">Redis学习-主从、哨兵、集群<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://xingliuhua/github.com.io" target="_blank">xingliuhua</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":15},"comment":{"gitalk":{"admin":["xingliuhua"],"clientID":"c0161bf1d93ccdd5f765","clientSecret":"3782f9a39ee0849148faa2ec75bb19d9964dda16","id":"2017-04-16T17:55:28+08:00","owner":"xingliuhua","repo":"xingliuhua.github.io","title":"Redis学习（二）-redis进阶"}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
